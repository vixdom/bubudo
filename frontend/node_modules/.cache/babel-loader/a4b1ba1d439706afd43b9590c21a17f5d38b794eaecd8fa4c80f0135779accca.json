{"ast":null,"code":"import { findYearClosestToRef } from \"../../../calculation/years.js\";\nimport { MONTH_DICTIONARY } from \"../constants.js\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants.js\";\nimport { YEAR_PATTERN, parseYear } from \"../constants.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nconst PATTERN = new RegExp(\"(?:on\\\\s*?)?\" + `(${ORDINAL_NUMBER_PATTERN})` + \"(?:\\\\s*\" + \"(?:tot|\\\\-|\\\\–|until|through|till|\\\\s)\\\\s*\" + `(${ORDINAL_NUMBER_PATTERN})` + \")?\" + \"(?:-|/|\\\\s*(?:of)?\\\\s*)\" + \"(\" + matchAnyPattern(MONTH_DICTIONARY) + \")\" + \"(?:\" + \"(?:-|/|,?\\\\s*)\" + `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` + \")?\" + \"(?=\\\\W|$)\", \"i\");\nconst MONTH_NAME_GROUP = 3;\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst YEAR_GROUP = 4;\nexport default class NLMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n    const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n    if (day > 31) {\n      match.index = match.index + match[DATE_GROUP].length;\n      return null;\n    }\n    const components = context.createParsingComponents({\n      day: day,\n      month: month\n    });\n    if (match[YEAR_GROUP]) {\n      const year = parseYear(match[YEAR_GROUP]);\n      components.assign(\"year\", year);\n    } else {\n      const year = findYearClosestToRef(context.refDate, day, month);\n      components.imply(\"year\", year);\n    }\n    if (!match[DATE_TO_GROUP]) {\n      return components;\n    }\n    const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n    const result = context.createParsingResult(match.index, match[0]);\n    result.start = components;\n    result.end = components.clone();\n    result.end.assign(\"day\", endDate);\n    return result;\n  }\n}","map":{"version":3,"names":["findYearClosestToRef","MONTH_DICTIONARY","ORDINAL_NUMBER_PATTERN","parseOrdinalNumberPattern","YEAR_PATTERN","parseYear","matchAnyPattern","AbstractParserWithWordBoundaryChecking","PATTERN","RegExp","MONTH_NAME_GROUP","DATE_GROUP","DATE_TO_GROUP","YEAR_GROUP","NLMonthNameMiddleEndianParser","innerPattern","innerExtract","context","match","month","toLowerCase","day","index","length","components","createParsingComponents","year","assign","refDate","imply","endDate","result","createParsingResult","start","end","clone"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/nl/parsers/NLMonthNameMiddleEndianParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"(?:on\\\\s*?)?\" +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        \"(?:\\\\s*\" +\n        \"(?:tot|\\\\-|\\\\–|until|through|till|\\\\s)\\\\s*\" +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        \")?\" +\n        \"(?:-|/|\\\\s*(?:of)?\\\\s*)\" +\n        \"(\" +\n        matchAnyPattern(MONTH_DICTIONARY) +\n        \")\" +\n        \"(?:\" +\n        \"(?:-|/|,?\\\\s*)\" +\n        `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` +\n        \")?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 3;\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst YEAR_GROUP = 4;\n\n/**\n * The parser for parsing BE/NL date format with month's name in full writing\n *  - 1 januari 2019\n *  - 01 januari 2019\n *  - 10 januari 2019\n *  - 13 januari\n *  - 10 - 25 maart\n *  - 10 - 25 maart 2019\n *  - 1 aug 2019\n *  - 1 september 200 voor Christus\n *  - 1 september 2002 na Christus\n *  - 19 januari 87\n *  - 12de juli 2013\n *  - 1ste november 2013\n */\nexport default class NLMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        const components = context.createParsingComponents({\n            day: day,\n            month: month,\n        });\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n\n        if (!match[DATE_TO_GROUP]) {\n            return components;\n        }\n\n        // Text can be 'range' value. Such as 'January 12 - 13, 2012'\n        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = components;\n        result.end = components.clone();\n        result.end.assign(\"day\", endDate);\n\n        return result;\n    }\n}\n"],"mappings":"AACA,SAASA,oBAAoB,QAAQ,+BAA6B;AAClE,SAASC,gBAAgB,QAAQ,iBAAe;AAChD,SAASC,sBAAsB,EAAEC,yBAAyB,QAAQ,iBAAe;AACjF,SAASC,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AACvD,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,sCAAsC,QAAQ,2DAAyD;AAEhH,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,cAAc,GACV,IAAIP,sBAAsB,GAAG,GAC7B,SAAS,GACT,4CAA4C,GAC5C,IAAIA,sBAAsB,GAAG,GAC7B,IAAI,GACJ,yBAAyB,GACzB,GAAG,GACHI,eAAe,CAACL,gBAAgB,CAAC,GACjC,GAAG,GACH,KAAK,GACL,gBAAgB,GAChB,IAAIG,YAAY,gBAAgB,GAChC,IAAI,GACJ,WAAW,EACf,GAAG,CACN;AAED,MAAMM,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,UAAU,GAAG,CAAC;AAiBpB,eAAc,MAAOC,6BAA8B,SAAQP,sCAAsC;EAC7FQ,YAAYA,CAAA;IACR,OAAOP,OAAO;EAClB;EAEAQ,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IACzD,MAAMC,KAAK,GAAGlB,gBAAgB,CAACiB,KAAK,CAACR,gBAAgB,CAAC,CAACU,WAAW,EAAE,CAAC;IACrE,MAAMC,GAAG,GAAGlB,yBAAyB,CAACe,KAAK,CAACP,UAAU,CAAC,CAAC;IACxD,IAAIU,GAAG,GAAG,EAAE,EAAE;MAEVH,KAAK,CAACI,KAAK,GAAGJ,KAAK,CAACI,KAAK,GAAGJ,KAAK,CAACP,UAAU,CAAC,CAACY,MAAM;MACpD,OAAO,IAAI;;IAGf,MAAMC,UAAU,GAAGP,OAAO,CAACQ,uBAAuB,CAAC;MAC/CJ,GAAG,EAAEA,GAAG;MACRF,KAAK,EAAEA;KACV,CAAC;IAEF,IAAID,KAAK,CAACL,UAAU,CAAC,EAAE;MACnB,MAAMa,IAAI,GAAGrB,SAAS,CAACa,KAAK,CAACL,UAAU,CAAC,CAAC;MACzCW,UAAU,CAACG,MAAM,CAAC,MAAM,EAAED,IAAI,CAAC;KAClC,MAAM;MACH,MAAMA,IAAI,GAAG1B,oBAAoB,CAACiB,OAAO,CAACW,OAAO,EAAEP,GAAG,EAAEF,KAAK,CAAC;MAC9DK,UAAU,CAACK,KAAK,CAAC,MAAM,EAAEH,IAAI,CAAC;;IAGlC,IAAI,CAACR,KAAK,CAACN,aAAa,CAAC,EAAE;MACvB,OAAOY,UAAU;;IAIrB,MAAMM,OAAO,GAAG3B,yBAAyB,CAACe,KAAK,CAACN,aAAa,CAAC,CAAC;IAC/D,MAAMmB,MAAM,GAAGd,OAAO,CAACe,mBAAmB,CAACd,KAAK,CAACI,KAAK,EAAEJ,KAAK,CAAC,CAAC,CAAC,CAAC;IACjEa,MAAM,CAACE,KAAK,GAAGT,UAAU;IACzBO,MAAM,CAACG,GAAG,GAAGV,UAAU,CAACW,KAAK,EAAE;IAC/BJ,MAAM,CAACG,GAAG,CAACP,MAAM,CAAC,KAAK,EAAEG,OAAO,CAAC;IAEjC,OAAOC,MAAM;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}