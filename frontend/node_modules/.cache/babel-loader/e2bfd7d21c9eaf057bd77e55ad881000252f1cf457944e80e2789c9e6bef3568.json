{"ast":null,"code":"import { findYearClosestToRef } from \"../../../calculation/years.js\";\nimport { MONTH_DICTIONARY } from \"../constants.js\";\nimport { YEAR_PATTERN, parseYear } from \"../constants.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nconst PATTERN = new RegExp(`([0-9]{1,2})(?:º|ª|°)?` + \"(?:\\\\s*(?:desde|de|\\\\-|\\\\–|ao?|\\\\s)\\\\s*([0-9]{1,2})(?:º|ª|°)?)?\\\\s*(?:de)?\\\\s*\" + `(?:-|/|\\\\s*(?:de|,)?\\\\s*)` + `(${matchAnyPattern(MONTH_DICTIONARY)})` + `(?:\\\\s*(?:de|,)?\\\\s*(${YEAR_PATTERN}))?` + `(?=\\\\W|$)`, \"i\");\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\nexport default class ESMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const result = context.createParsingResult(match.index, match[0]);\n    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n    const day = parseInt(match[DATE_GROUP]);\n    if (day > 31) {\n      match.index = match.index + match[DATE_GROUP].length;\n      return null;\n    }\n    result.start.assign(\"month\", month);\n    result.start.assign(\"day\", day);\n    if (match[YEAR_GROUP]) {\n      const yearNumber = parseYear(match[YEAR_GROUP]);\n      result.start.assign(\"year\", yearNumber);\n    } else {\n      const year = findYearClosestToRef(context.refDate, day, month);\n      result.start.imply(\"year\", year);\n    }\n    if (match[DATE_TO_GROUP]) {\n      const endDate = parseInt(match[DATE_TO_GROUP]);\n      result.end = result.start.clone();\n      result.end.assign(\"day\", endDate);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["findYearClosestToRef","MONTH_DICTIONARY","YEAR_PATTERN","parseYear","matchAnyPattern","AbstractParserWithWordBoundaryChecking","PATTERN","RegExp","DATE_GROUP","DATE_TO_GROUP","MONTH_NAME_GROUP","YEAR_GROUP","ESMonthNameLittleEndianParser","innerPattern","innerExtract","context","match","result","createParsingResult","index","month","toLowerCase","day","parseInt","length","start","assign","yearNumber","year","refDate","imply","endDate","end","clone"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/es/parsers/ESMonthNameLittleEndianParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `([0-9]{1,2})(?:º|ª|°)?` +\n        \"(?:\\\\s*(?:desde|de|\\\\-|\\\\–|ao?|\\\\s)\\\\s*([0-9]{1,2})(?:º|ª|°)?)?\\\\s*(?:de)?\\\\s*\" +\n        `(?:-|/|\\\\s*(?:de|,)?\\\\s*)` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:\\\\s*(?:de|,)?\\\\s*(${YEAR_PATTERN}))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class ESMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseInt(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseInt(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ,+BAA6B;AAClE,SAASC,gBAAgB,QAAQ,iBAAe;AAChD,SAASC,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AACvD,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,sCAAsC,QAAQ,2DAAyD;AAEhH,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,wBAAwB,GACpB,gFAAgF,GAChF,2BAA2B,GAC3B,IAAIH,eAAe,CAACH,gBAAgB,CAAC,GAAG,GACxC,wBAAwBC,YAAY,KAAK,GACzC,WAAW,EACf,GAAG,CACN;AAED,MAAMM,UAAU,GAAG,CAAC;AACpB,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,UAAU,GAAG,CAAC;AAEpB,eAAc,MAAOC,6BAA8B,SAAQP,sCAAsC;EAC7FQ,YAAYA,CAAA;IACR,OAAOP,OAAO;EAClB;EAEAQ,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IACzD,MAAMC,MAAM,GAAGF,OAAO,CAACG,mBAAmB,CAACF,KAAK,CAACG,KAAK,EAAEH,KAAK,CAAC,CAAC,CAAC,CAAC;IAEjE,MAAMI,KAAK,GAAGnB,gBAAgB,CAACe,KAAK,CAACN,gBAAgB,CAAC,CAACW,WAAW,EAAE,CAAC;IACrE,MAAMC,GAAG,GAAGC,QAAQ,CAACP,KAAK,CAACR,UAAU,CAAC,CAAC;IACvC,IAAIc,GAAG,GAAG,EAAE,EAAE;MAEVN,KAAK,CAACG,KAAK,GAAGH,KAAK,CAACG,KAAK,GAAGH,KAAK,CAACR,UAAU,CAAC,CAACgB,MAAM;MACpD,OAAO,IAAI;;IAGfP,MAAM,CAACQ,KAAK,CAACC,MAAM,CAAC,OAAO,EAAEN,KAAK,CAAC;IACnCH,MAAM,CAACQ,KAAK,CAACC,MAAM,CAAC,KAAK,EAAEJ,GAAG,CAAC;IAE/B,IAAIN,KAAK,CAACL,UAAU,CAAC,EAAE;MACnB,MAAMgB,UAAU,GAAGxB,SAAS,CAACa,KAAK,CAACL,UAAU,CAAC,CAAC;MAC/CM,MAAM,CAACQ,KAAK,CAACC,MAAM,CAAC,MAAM,EAAEC,UAAU,CAAC;KAC1C,MAAM;MACH,MAAMC,IAAI,GAAG5B,oBAAoB,CAACe,OAAO,CAACc,OAAO,EAAEP,GAAG,EAAEF,KAAK,CAAC;MAC9DH,MAAM,CAACQ,KAAK,CAACK,KAAK,CAAC,MAAM,EAAEF,IAAI,CAAC;;IAGpC,IAAIZ,KAAK,CAACP,aAAa,CAAC,EAAE;MACtB,MAAMsB,OAAO,GAAGR,QAAQ,CAACP,KAAK,CAACP,aAAa,CAAC,CAAC;MAE9CQ,MAAM,CAACe,GAAG,GAAGf,MAAM,CAACQ,KAAK,CAACQ,KAAK,EAAE;MACjChB,MAAM,CAACe,GAAG,CAACN,MAAM,CAAC,KAAK,EAAEK,OAAO,CAAC;;IAGrC,OAAOd,MAAM;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}