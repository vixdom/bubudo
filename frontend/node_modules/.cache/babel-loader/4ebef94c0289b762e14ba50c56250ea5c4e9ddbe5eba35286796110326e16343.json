{"ast":null,"code":"import { WEEKDAY_DICTIONARY } from \"../constants.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays.js\";\nimport { Weekday } from \"../../../types.js\";\nconst PATTERN = new RegExp(\"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" + \"(?:on\\\\s*?)?\" + \"(?:(this|last|past|next)\\\\s*)?\" + `(${matchAnyPattern(WEEKDAY_DICTIONARY)}|weekend|weekday)` + \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" + \"(?:\\\\s*(this|last|past|next)\\\\s*week)?\" + \"(?=\\\\W|$)\", \"i\");\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\nexport default class ENWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const prefix = match[PREFIX_GROUP];\n    const postfix = match[POSTFIX_GROUP];\n    let modifierWord = prefix || postfix;\n    modifierWord = modifierWord || \"\";\n    modifierWord = modifierWord.toLowerCase();\n    let modifier = null;\n    if (modifierWord == \"last\" || modifierWord == \"past\") {\n      modifier = \"last\";\n    } else if (modifierWord == \"next\") {\n      modifier = \"next\";\n    } else if (modifierWord == \"this\") {\n      modifier = \"this\";\n    }\n    const weekday_word = match[WEEKDAY_GROUP].toLowerCase();\n    let weekday;\n    if (WEEKDAY_DICTIONARY[weekday_word] !== undefined) {\n      weekday = WEEKDAY_DICTIONARY[weekday_word];\n    } else if (weekday_word == \"weekend\") {\n      weekday = modifier == \"last\" ? Weekday.SUNDAY : Weekday.SATURDAY;\n    } else if (weekday_word == \"weekday\") {\n      const refWeekday = context.reference.getDateWithAdjustedTimezone().getDay();\n      if (refWeekday == Weekday.SUNDAY || refWeekday == Weekday.SATURDAY) {\n        weekday = modifier == \"last\" ? Weekday.FRIDAY : Weekday.MONDAY;\n      } else {\n        weekday = refWeekday - 1;\n        weekday = modifier == \"last\" ? weekday - 1 : weekday + 1;\n        weekday = weekday % 5 + 1;\n      }\n    } else {\n      return null;\n    }\n    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n  }\n}","map":{"version":3,"names":["WEEKDAY_DICTIONARY","matchAnyPattern","AbstractParserWithWordBoundaryChecking","createParsingComponentsAtWeekday","Weekday","PATTERN","RegExp","PREFIX_GROUP","WEEKDAY_GROUP","POSTFIX_GROUP","ENWeekdayParser","innerPattern","innerExtract","context","match","prefix","postfix","modifierWord","toLowerCase","modifier","weekday_word","weekday","undefined","SUNDAY","SATURDAY","refWeekday","reference","getDateWithAdjustedTimezone","getDay","FRIDAY","MONDAY"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/en/parsers/ENWeekdayParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\nimport { Weekday } from \"../../../types\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:on\\\\s*?)?\" +\n        \"(?:(this|last|past|next)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)}|weekend|weekday)` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(this|last|past|next)\\\\s*week)?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class ENWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord == \"last\" || modifierWord == \"past\") {\n            modifier = \"last\";\n        } else if (modifierWord == \"next\") {\n            modifier = \"next\";\n        } else if (modifierWord == \"this\") {\n            modifier = \"this\";\n        }\n\n        const weekday_word = match[WEEKDAY_GROUP].toLowerCase();\n        let weekday;\n        if (WEEKDAY_DICTIONARY[weekday_word] !== undefined) {\n            weekday = WEEKDAY_DICTIONARY[weekday_word];\n        } else if (weekday_word == \"weekend\") {\n            // This depends on what days are weekend setting, but typically:\n            // 'This/next weekend' means the coming Saturday, 'last weekend' means last Sunday.\n            weekday = modifier == \"last\" ? Weekday.SUNDAY : Weekday.SATURDAY;\n        } else if (weekday_word == \"weekday\") {\n            // In English, the \"weekday\" means any day of the week except weekend.\n            // This also depends on what days are weekend setting, but typically:\n            // - On weekend ref, this means the coming Monday or last Friday.\n            // - On weekday ref, this means the next/last working day.\n            const refWeekday = context.reference.getDateWithAdjustedTimezone().getDay();\n            if (refWeekday == Weekday.SUNDAY || refWeekday == Weekday.SATURDAY) {\n                weekday = modifier == \"last\" ? Weekday.FRIDAY : Weekday.MONDAY;\n            } else {\n                weekday = refWeekday - 1;\n                weekday = modifier == \"last\" ? weekday - 1 : weekday + 1;\n                weekday = (weekday % 5) + 1;\n            }\n        } else {\n            return null;\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n"],"mappings":"AAEA,SAASA,kBAAkB,QAAQ,iBAAe;AAClD,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,sCAAsC,QAAQ,2DAAyD;AAChH,SAASC,gCAAgC,QAAQ,yCAAuC;AACxF,SAASC,OAAO,QAAQ,mBAAiB;AAEzC,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,0BAA0B,GACtB,cAAc,GACd,gCAAgC,GAChC,IAAIL,eAAe,CAACD,kBAAkB,CAAC,mBAAmB,GAC1D,0BAA0B,GAC1B,wCAAwC,GACxC,WAAW,EACf,GAAG,CACN;AAED,MAAMO,YAAY,GAAG,CAAC;AACtB,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,aAAa,GAAG,CAAC;AAEvB,eAAc,MAAOC,eAAgB,SAAQR,sCAAsC;EAC/ES,YAAYA,CAAA;IACR,OAAON,OAAO;EAClB;EAEAO,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IACzD,MAAMC,MAAM,GAAGD,KAAK,CAACP,YAAY,CAAC;IAClC,MAAMS,OAAO,GAAGF,KAAK,CAACL,aAAa,CAAC;IACpC,IAAIQ,YAAY,GAAGF,MAAM,IAAIC,OAAO;IACpCC,YAAY,GAAGA,YAAY,IAAI,EAAE;IACjCA,YAAY,GAAGA,YAAY,CAACC,WAAW,EAAE;IAEzC,IAAIC,QAAQ,GAAG,IAAI;IACnB,IAAIF,YAAY,IAAI,MAAM,IAAIA,YAAY,IAAI,MAAM,EAAE;MAClDE,QAAQ,GAAG,MAAM;KACpB,MAAM,IAAIF,YAAY,IAAI,MAAM,EAAE;MAC/BE,QAAQ,GAAG,MAAM;KACpB,MAAM,IAAIF,YAAY,IAAI,MAAM,EAAE;MAC/BE,QAAQ,GAAG,MAAM;;IAGrB,MAAMC,YAAY,GAAGN,KAAK,CAACN,aAAa,CAAC,CAACU,WAAW,EAAE;IACvD,IAAIG,OAAO;IACX,IAAIrB,kBAAkB,CAACoB,YAAY,CAAC,KAAKE,SAAS,EAAE;MAChDD,OAAO,GAAGrB,kBAAkB,CAACoB,YAAY,CAAC;KAC7C,MAAM,IAAIA,YAAY,IAAI,SAAS,EAAE;MAGlCC,OAAO,GAAGF,QAAQ,IAAI,MAAM,GAAGf,OAAO,CAACmB,MAAM,GAAGnB,OAAO,CAACoB,QAAQ;KACnE,MAAM,IAAIJ,YAAY,IAAI,SAAS,EAAE;MAKlC,MAAMK,UAAU,GAAGZ,OAAO,CAACa,SAAS,CAACC,2BAA2B,EAAE,CAACC,MAAM,EAAE;MAC3E,IAAIH,UAAU,IAAIrB,OAAO,CAACmB,MAAM,IAAIE,UAAU,IAAIrB,OAAO,CAACoB,QAAQ,EAAE;QAChEH,OAAO,GAAGF,QAAQ,IAAI,MAAM,GAAGf,OAAO,CAACyB,MAAM,GAAGzB,OAAO,CAAC0B,MAAM;OACjE,MAAM;QACHT,OAAO,GAAGI,UAAU,GAAG,CAAC;QACxBJ,OAAO,GAAGF,QAAQ,IAAI,MAAM,GAAGE,OAAO,GAAG,CAAC,GAAGA,OAAO,GAAG,CAAC;QACxDA,OAAO,GAAIA,OAAO,GAAG,CAAC,GAAI,CAAC;;KAElC,MAAM;MACH,OAAO,IAAI;;IAGf,OAAOlB,gCAAgC,CAACU,OAAO,CAACa,SAAS,EAAEL,OAAO,EAAEF,QAAQ,CAAC;EACjF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}