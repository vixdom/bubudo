{"ast":null,"code":"import { MergingRefiner } from \"../../../common/abstractRefiners.js\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results.js\";\nimport { parseTimeUnits } from \"../constants.js\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits.js\";\nfunction hasImpliedEarlierReferenceDate(result) {\n  return result.text.match(/\\s+(before|from)$/i) != null;\n}\nfunction hasImpliedLaterReferenceDate(result) {\n  return result.text.match(/\\s+(after|since)$/i) != null;\n}\nexport default class ENMergeRelativeFollowByDateRefiner extends MergingRefiner {\n  patternBetween() {\n    return /^\\s*$/i;\n  }\n  shouldMergeResults(textBetween, currentResult, nextResult) {\n    if (!textBetween.match(this.patternBetween())) {\n      return false;\n    }\n    if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n      return false;\n    }\n    return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n  }\n  mergeResults(textBetween, currentResult, nextResult) {\n    let timeUnits = parseTimeUnits(currentResult.text);\n    if (hasImpliedEarlierReferenceDate(currentResult)) {\n      timeUnits = reverseTimeUnits(timeUnits);\n    }\n    const components = ParsingComponents.createRelativeFromReference(new ReferenceWithTimezone(nextResult.start.date()), timeUnits);\n    return new ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);\n  }\n}","map":{"version":3,"names":["MergingRefiner","ParsingComponents","ParsingResult","ReferenceWithTimezone","parseTimeUnits","reverseTimeUnits","hasImpliedEarlierReferenceDate","result","text","match","hasImpliedLaterReferenceDate","ENMergeRelativeFollowByDateRefiner","patternBetween","shouldMergeResults","textBetween","currentResult","nextResult","start","get","mergeResults","timeUnits","components","createRelativeFromReference","date","reference","index"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/en/refiners/ENMergeRelativeFollowByDateRefiner.ts"],"sourcesContent":["import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseTimeUnits } from \"../constants\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nfunction hasImpliedEarlierReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(before|from)$/i) != null;\n}\n\nfunction hasImpliedLaterReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(after|since)$/i) != null;\n}\n\n/**\n * Merges a relative data/time that follow by an absolute date.\n * - [2 weeks before] [2020-02-13]\n * - [2 days after] [next Friday]\n */\nexport default class ENMergeRelativeFollowByDateRefiner extends MergingRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        // Dates need to be next to each other to get merged\n        if (!textBetween.match(this.patternBetween())) {\n            return false;\n        }\n\n        // Check if any relative tokens were swallowed by the first date.\n        // E.g. [<relative_date1> from] [<date2>]\n        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n            return false;\n        }\n\n        // make sure that <date2> implies an absolute date\n        return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        let timeUnits = parseTimeUnits(currentResult.text);\n        if (hasImpliedEarlierReferenceDate(currentResult)) {\n            timeUnits = reverseTimeUnits(timeUnits);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            new ReferenceWithTimezone(nextResult.start.date()),\n            timeUnits\n        );\n\n        return new ParsingResult(\n            nextResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,qCAAmC;AAClE,SAASC,iBAAiB,EAAEC,aAAa,EAAEC,qBAAqB,QAAQ,qBAAmB;AAC3F,SAASC,cAAc,QAAQ,iBAAe;AAC9C,SAASC,gBAAgB,QAAQ,6BAA2B;AAE5D,SAASC,8BAA8BA,CAACC,MAAqB;EACzD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,oBAAoB,CAAC,IAAI,IAAI;AAC1D;AAEA,SAASC,4BAA4BA,CAACH,MAAqB;EACvD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,oBAAoB,CAAC,IAAI,IAAI;AAC1D;AAOA,eAAc,MAAOE,kCAAmC,SAAQX,cAAc;EAC1EY,cAAcA,CAAA;IACV,OAAO,QAAQ;EACnB;EAEAC,kBAAkBA,CAACC,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB;IAE3F,IAAI,CAACF,WAAW,CAACL,KAAK,CAAC,IAAI,CAACG,cAAc,EAAE,CAAC,EAAE;MAC3C,OAAO,KAAK;;IAKhB,IAAI,CAACN,8BAA8B,CAACS,aAAa,CAAC,IAAI,CAACL,4BAA4B,CAACK,aAAa,CAAC,EAAE;MAChG,OAAO,KAAK;;IAIhB,OAAO,CAAC,CAACC,UAAU,CAACC,KAAK,CAACC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAACF,UAAU,CAACC,KAAK,CAACC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAACF,UAAU,CAACC,KAAK,CAACC,GAAG,CAAC,MAAM,CAAC;EAC7G;EAEAC,YAAYA,CAACL,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB;IACrF,IAAII,SAAS,GAAGhB,cAAc,CAACW,aAAa,CAACP,IAAI,CAAC;IAClD,IAAIF,8BAA8B,CAACS,aAAa,CAAC,EAAE;MAC/CK,SAAS,GAAGf,gBAAgB,CAACe,SAAS,CAAC;;IAG3C,MAAMC,UAAU,GAAGpB,iBAAiB,CAACqB,2BAA2B,CAC5D,IAAInB,qBAAqB,CAACa,UAAU,CAACC,KAAK,CAACM,IAAI,EAAE,CAAC,EAClDH,SAAS,CACZ;IAED,OAAO,IAAIlB,aAAa,CACpBc,UAAU,CAACQ,SAAS,EACpBT,aAAa,CAACU,KAAK,EACnB,GAAGV,aAAa,CAACP,IAAI,GAAGM,WAAW,GAAGE,UAAU,CAACR,IAAI,EAAE,EACvDa,UAAU,CACb;EACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}