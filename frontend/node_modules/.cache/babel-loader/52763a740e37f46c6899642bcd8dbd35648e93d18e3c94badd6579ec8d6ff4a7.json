{"ast":null,"code":"import { MergingRefiner } from \"../abstractRefiners.js\";\nexport default class AbstractMergeDateRangeRefiner extends MergingRefiner {\n  shouldMergeResults(textBetween, currentResult, nextResult) {\n    return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;\n  }\n  mergeResults(textBetween, fromResult, toResult) {\n    if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {\n      toResult.start.getCertainComponents().forEach(key => {\n        if (!fromResult.start.isCertain(key)) {\n          fromResult.start.imply(key, toResult.start.get(key));\n        }\n      });\n      fromResult.start.getCertainComponents().forEach(key => {\n        if (!toResult.start.isCertain(key)) {\n          toResult.start.imply(key, fromResult.start.get(key));\n        }\n      });\n    }\n    if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {\n      let fromMoment = fromResult.start.dayjs();\n      let toMoment = toResult.start.dayjs();\n      if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, \"days\").isAfter(fromMoment)) {\n        toMoment = toMoment.add(7, \"days\");\n        toResult.start.imply(\"day\", toMoment.date());\n        toResult.start.imply(\"month\", toMoment.month() + 1);\n        toResult.start.imply(\"year\", toMoment.year());\n      } else if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, \"days\").isBefore(toMoment)) {\n        fromMoment = fromMoment.add(-7, \"days\");\n        fromResult.start.imply(\"day\", fromMoment.date());\n        fromResult.start.imply(\"month\", fromMoment.month() + 1);\n        fromResult.start.imply(\"year\", fromMoment.year());\n      } else if (toResult.start.isDateWithUnknownYear() && toMoment.add(1, \"years\").isAfter(fromMoment)) {\n        toMoment = toMoment.add(1, \"years\");\n        toResult.start.imply(\"year\", toMoment.year());\n      } else if (fromResult.start.isDateWithUnknownYear() && fromMoment.add(-1, \"years\").isBefore(toMoment)) {\n        fromMoment = fromMoment.add(-1, \"years\");\n        fromResult.start.imply(\"year\", fromMoment.year());\n      } else {\n        [toResult, fromResult] = [fromResult, toResult];\n      }\n    }\n    const result = fromResult.clone();\n    result.start = fromResult.start;\n    result.end = toResult.start;\n    result.index = Math.min(fromResult.index, toResult.index);\n    if (fromResult.index < toResult.index) {\n      result.text = fromResult.text + textBetween + toResult.text;\n    } else {\n      result.text = toResult.text + textBetween + fromResult.text;\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["MergingRefiner","AbstractMergeDateRangeRefiner","shouldMergeResults","textBetween","currentResult","nextResult","end","match","patternBetween","mergeResults","fromResult","toResult","start","isOnlyWeekdayComponent","getCertainComponents","forEach","key","isCertain","imply","get","date","getTime","fromMoment","dayjs","toMoment","add","isAfter","month","year","isBefore","isDateWithUnknownYear","result","clone","index","Math","min","text"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/common/refiners/AbstractMergeDateRangeRefiner.ts"],"sourcesContent":["/*\n  \n*/\n\nimport { ParsingResult } from \"../../results\";\nimport { MergingRefiner } from \"../abstractRefiners\";\n\nexport default abstract class AbstractMergeDateRangeRefiner extends MergingRefiner {\n    abstract patternBetween(): RegExp;\n\n    shouldMergeResults(textBetween, currentResult, nextResult): boolean {\n        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;\n    }\n\n    mergeResults(textBetween, fromResult, toResult): ParsingResult {\n        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {\n            toResult.start.getCertainComponents().forEach((key) => {\n                if (!fromResult.start.isCertain(key)) {\n                    fromResult.start.imply(key, toResult.start.get(key));\n                }\n            });\n\n            fromResult.start.getCertainComponents().forEach((key) => {\n                if (!toResult.start.isCertain(key)) {\n                    toResult.start.imply(key, fromResult.start.get(key));\n                }\n            });\n        }\n\n        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {\n            let fromMoment = fromResult.start.dayjs();\n            let toMoment = toResult.start.dayjs();\n            if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, \"days\").isAfter(fromMoment)) {\n                toMoment = toMoment.add(7, \"days\");\n                toResult.start.imply(\"day\", toMoment.date());\n                toResult.start.imply(\"month\", toMoment.month() + 1);\n                toResult.start.imply(\"year\", toMoment.year());\n            } else if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, \"days\").isBefore(toMoment)) {\n                fromMoment = fromMoment.add(-7, \"days\");\n                fromResult.start.imply(\"day\", fromMoment.date());\n                fromResult.start.imply(\"month\", fromMoment.month() + 1);\n                fromResult.start.imply(\"year\", fromMoment.year());\n            } else if (toResult.start.isDateWithUnknownYear() && toMoment.add(1, \"years\").isAfter(fromMoment)) {\n                toMoment = toMoment.add(1, \"years\");\n                toResult.start.imply(\"year\", toMoment.year());\n            } else if (fromResult.start.isDateWithUnknownYear() && fromMoment.add(-1, \"years\").isBefore(toMoment)) {\n                fromMoment = fromMoment.add(-1, \"years\");\n                fromResult.start.imply(\"year\", fromMoment.year());\n            } else {\n                [toResult, fromResult] = [fromResult, toResult];\n            }\n        }\n\n        const result = fromResult.clone();\n        result.start = fromResult.start;\n        result.end = toResult.start;\n        result.index = Math.min(fromResult.index, toResult.index);\n        if (fromResult.index < toResult.index) {\n            result.text = fromResult.text + textBetween + toResult.text;\n        } else {\n            result.text = toResult.text + textBetween + fromResult.text;\n        }\n\n        return result;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}