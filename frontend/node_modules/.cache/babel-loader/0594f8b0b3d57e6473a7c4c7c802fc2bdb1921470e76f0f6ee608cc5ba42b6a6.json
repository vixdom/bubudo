{"ast":null,"code":"import { findYearClosestToRef } from \"../../../calculation/years.js\";\nimport { MONTH_DICTIONARY } from \"../constants.js\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants.js\";\nimport { YEAR_PATTERN, parseYear } from \"../constants.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nconst PATTERN = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY)})` + \"(?:-|/|\\\\s*,?\\\\s*)\" + `(${ORDINAL_NUMBER_PATTERN})(?!\\\\s*(?:am|pm))\\\\s*` + \"(?:\" + \"(?:to|\\\\-)\\\\s*\" + `(${ORDINAL_NUMBER_PATTERN})\\\\s*` + \")?\" + \"(?:\" + `(?:-|/|\\\\s*,\\\\s*|\\\\s+)` + `(${YEAR_PATTERN})` + \")?\" + \"(?=\\\\W|$)(?!\\\\:\\\\d)\", \"i\");\nconst MONTH_NAME_GROUP = 1;\nconst DATE_GROUP = 2;\nconst DATE_TO_GROUP = 3;\nconst YEAR_GROUP = 4;\nexport default class ENMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n  constructor(shouldSkipYearLikeDate) {\n    super();\n    this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;\n  }\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n    const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n    if (day > 31) {\n      return null;\n    }\n    if (this.shouldSkipYearLikeDate) {\n      if (!match[DATE_TO_GROUP] && !match[YEAR_GROUP] && match[DATE_GROUP].match(/^2[0-5]$/)) {\n        return null;\n      }\n    }\n    const components = context.createParsingComponents({\n      day: day,\n      month: month\n    }).addTag(\"parser/ENMonthNameMiddleEndianParser\");\n    if (match[YEAR_GROUP]) {\n      const year = parseYear(match[YEAR_GROUP]);\n      components.assign(\"year\", year);\n    } else {\n      const year = findYearClosestToRef(context.refDate, day, month);\n      components.imply(\"year\", year);\n    }\n    if (!match[DATE_TO_GROUP]) {\n      return components;\n    }\n    const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n    const result = context.createParsingResult(match.index, match[0]);\n    result.start = components;\n    result.end = components.clone();\n    result.end.assign(\"day\", endDate);\n    return result;\n  }\n}","map":{"version":3,"names":["findYearClosestToRef","MONTH_DICTIONARY","ORDINAL_NUMBER_PATTERN","parseOrdinalNumberPattern","YEAR_PATTERN","parseYear","matchAnyPattern","AbstractParserWithWordBoundaryChecking","PATTERN","RegExp","MONTH_NAME_GROUP","DATE_GROUP","DATE_TO_GROUP","YEAR_GROUP","ENMonthNameMiddleEndianParser","constructor","shouldSkipYearLikeDate","innerPattern","innerExtract","context","match","month","toLowerCase","day","components","createParsingComponents","addTag","year","assign","refDate","imply","endDate","result","createParsingResult","index","start","end","clone"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/en/parsers/ENMonthNameMiddleEndianParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:-|/|\\\\s*,?\\\\s*)\" +\n        `(${ORDINAL_NUMBER_PATTERN})(?!\\\\s*(?:am|pm))\\\\s*` +\n        \"(?:\" +\n            \"(?:to|\\\\-)\\\\s*\" +\n            `(${ORDINAL_NUMBER_PATTERN})\\\\s*` +\n        \")?\" +\n        \"(?:\" +\n            `(?:-|/|\\\\s*,\\\\s*|\\\\s+)` +\n            `(${YEAR_PATTERN})` +\n        \")?\" +\n        \"(?=\\\\W|$)(?!\\\\:\\\\d)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 1;\nconst DATE_GROUP = 2;\nconst DATE_TO_GROUP = 3;\nconst YEAR_GROUP = 4;\n\n/**\n * The parser for parsing US's date format that begin with month's name.\n *  - January 13\n *  - January 13, 2012\n *  - January 13 - 15, 2012\n * Note: Watch out for:\n *  - January 12:00\n *  - January 12.44\n *  - January 1222344\n *  - January 21 (when shouldSkipYearLikeDate=true)\n */\nexport default class ENMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    shouldSkipYearLikeDate: boolean;\n\n    constructor(shouldSkipYearLikeDate: boolean) {\n        super();\n        this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;\n    }\n\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            return null;\n        }\n\n        // Skip the case where the day looks like a year (ex: January 21)\n        if (this.shouldSkipYearLikeDate) {\n            if (!match[DATE_TO_GROUP] && !match[YEAR_GROUP] && match[DATE_GROUP].match(/^2[0-5]$/)) {\n                return null;\n            }\n        }\n        const components = context\n            .createParsingComponents({\n                day: day,\n                month: month,\n            })\n            .addTag(\"parser/ENMonthNameMiddleEndianParser\");\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n        if (!match[DATE_TO_GROUP]) {\n            return components;\n        }\n\n        // Text can be 'range' value. Such as 'January 12 - 13, 2012'\n        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = components;\n        result.end = components.clone();\n        result.end.assign(\"day\", endDate);\n\n        return result;\n    }\n}\n"],"mappings":"AACA,SAASA,oBAAoB,QAAQ,+BAA6B;AAClE,SAASC,gBAAgB,QAAQ,iBAAe;AAChD,SAASC,sBAAsB,EAAEC,yBAAyB,QAAQ,iBAAe;AACjF,SAASC,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AACvD,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,sCAAsC,QAAQ,2DAAyD;AAGhH,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,IAAIH,eAAe,CAACL,gBAAgB,CAAC,GAAG,GACpC,oBAAoB,GACpB,IAAIC,sBAAsB,wBAAwB,GAClD,KAAK,GACD,gBAAgB,GAChB,IAAIA,sBAAsB,OAAO,GACrC,IAAI,GACJ,KAAK,GACD,wBAAwB,GACxB,IAAIE,YAAY,GAAG,GACvB,IAAI,GACJ,qBAAqB,EACzB,GAAG,CACN;AAED,MAAMM,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,UAAU,GAAG,CAAC;AAapB,eAAc,MAAOC,6BAA8B,SAAQP,sCAAsC;EAG7FQ,YAAYC,sBAA+B;IACvC,KAAK,EAAE;IACP,IAAI,CAACA,sBAAsB,GAAGA,sBAAsB;EACxD;EAEAC,YAAYA,CAAA;IACR,OAAOT,OAAO;EAClB;EAEAU,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IACzD,MAAMC,KAAK,GAAGpB,gBAAgB,CAACmB,KAAK,CAACV,gBAAgB,CAAC,CAACY,WAAW,EAAE,CAAC;IACrE,MAAMC,GAAG,GAAGpB,yBAAyB,CAACiB,KAAK,CAACT,UAAU,CAAC,CAAC;IACxD,IAAIY,GAAG,GAAG,EAAE,EAAE;MACV,OAAO,IAAI;;IAIf,IAAI,IAAI,CAACP,sBAAsB,EAAE;MAC7B,IAAI,CAACI,KAAK,CAACR,aAAa,CAAC,IAAI,CAACQ,KAAK,CAACP,UAAU,CAAC,IAAIO,KAAK,CAACT,UAAU,CAAC,CAACS,KAAK,CAAC,UAAU,CAAC,EAAE;QACpF,OAAO,IAAI;;;IAGnB,MAAMI,UAAU,GAAGL,OAAO,CACrBM,uBAAuB,CAAC;MACrBF,GAAG,EAAEA,GAAG;MACRF,KAAK,EAAEA;KACV,CAAC,CACDK,MAAM,CAAC,sCAAsC,CAAC;IAEnD,IAAIN,KAAK,CAACP,UAAU,CAAC,EAAE;MACnB,MAAMc,IAAI,GAAGtB,SAAS,CAACe,KAAK,CAACP,UAAU,CAAC,CAAC;MACzCW,UAAU,CAACI,MAAM,CAAC,MAAM,EAAED,IAAI,CAAC;KAClC,MAAM;MACH,MAAMA,IAAI,GAAG3B,oBAAoB,CAACmB,OAAO,CAACU,OAAO,EAAEN,GAAG,EAAEF,KAAK,CAAC;MAC9DG,UAAU,CAACM,KAAK,CAAC,MAAM,EAAEH,IAAI,CAAC;;IAElC,IAAI,CAACP,KAAK,CAACR,aAAa,CAAC,EAAE;MACvB,OAAOY,UAAU;;IAIrB,MAAMO,OAAO,GAAG5B,yBAAyB,CAACiB,KAAK,CAACR,aAAa,CAAC,CAAC;IAC/D,MAAMoB,MAAM,GAAGb,OAAO,CAACc,mBAAmB,CAACb,KAAK,CAACc,KAAK,EAAEd,KAAK,CAAC,CAAC,CAAC,CAAC;IACjEY,MAAM,CAACG,KAAK,GAAGX,UAAU;IACzBQ,MAAM,CAACI,GAAG,GAAGZ,UAAU,CAACa,KAAK,EAAE;IAC/BL,MAAM,CAACI,GAAG,CAACR,MAAM,CAAC,KAAK,EAAEG,OAAO,CAAC;IAEjC,OAAOC,MAAM;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}