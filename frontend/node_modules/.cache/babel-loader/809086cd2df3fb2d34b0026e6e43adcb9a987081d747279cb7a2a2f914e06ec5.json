{"ast":null,"code":"import { NUMBER_PATTERN, parseNumberPattern, TIME_UNIT_DICTIONARY } from \"../constants.js\";\nimport { ParsingComponents } from \"../../../results.js\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nexport default class DETimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n  constructor() {\n    super();\n  }\n  innerPattern() {\n    return new RegExp(`(?:\\\\s*((?:n채chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\\\s*)?` + `(${NUMBER_PATTERN})?` + `(?:\\\\s*(n채chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?` + `\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`, \"i\");\n  }\n  innerExtract(context, match) {\n    const num = match[2] ? parseNumberPattern(match[2]) : 1;\n    const unit = TIME_UNIT_DICTIONARY[match[4].toLowerCase()];\n    let timeUnits = {};\n    timeUnits[unit] = num;\n    let modifier = match[1] || match[3] || \"\";\n    modifier = modifier.toLowerCase();\n    if (!modifier) {\n      return;\n    }\n    if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {\n      timeUnits = reverseTimeUnits(timeUnits);\n    }\n    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n  }\n}","map":{"version":3,"names":["NUMBER_PATTERN","parseNumberPattern","TIME_UNIT_DICTIONARY","ParsingComponents","AbstractParserWithWordBoundaryChecking","reverseTimeUnits","matchAnyPattern","DETimeUnitAgoFormatParser","constructor","innerPattern","RegExp","innerExtract","context","match","num","unit","toLowerCase","timeUnits","modifier","test","createRelativeFromReference","reference"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/de/parsers/DETimeUnitRelativeFormatParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { NUMBER_PATTERN, parseNumberPattern, TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\n\nexport default class DETimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor() {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return new RegExp(\n            `(?:\\\\s*((?:n채chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\\\s*)?` +\n                `(${NUMBER_PATTERN})?` +\n                `(?:\\\\s*(n채chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?` +\n                `\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`,\n            \"i\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const num = match[2] ? parseNumberPattern(match[2]) : 1;\n        const unit = TIME_UNIT_DICTIONARY[match[4].toLowerCase()];\n        let timeUnits = {};\n        timeUnits[unit] = num;\n\n        // Modifier\n        let modifier = match[1] || match[3] || \"\";\n        modifier = modifier.toLowerCase();\n        if (!modifier) {\n            return;\n        }\n\n        if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {\n            timeUnits = reverseTimeUnits(timeUnits);\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n"],"mappings":"AACA,SAASA,cAAc,EAAEC,kBAAkB,EAAEC,oBAAoB,QAAQ,iBAAe;AACxF,SAASC,iBAAiB,QAAQ,qBAAmB;AACrD,SAASC,sCAAsC,QAAQ,2DAAyD;AAChH,SAASC,gBAAgB,QAAQ,6BAA2B;AAC5D,SAASC,eAAe,QAAQ,2BAAyB;AAEzD,eAAc,MAAOC,yBAA0B,SAAQH,sCAAsC;EACzFI,YAAA;IACI,KAAK,EAAE;EACX;EAEAC,YAAYA,CAAA;IACR,OAAO,IAAIC,MAAM,CACb,iHAAiH,GAC7G,IAAIV,cAAc,IAAI,GACtB,kGAAkG,GAClG,QAAQM,eAAe,CAACJ,oBAAoB,CAAC,GAAG,EACpD,GAAG,CACN;EACL;EAEAS,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IACzD,MAAMC,GAAG,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAGZ,kBAAkB,CAACY,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;IACvD,MAAME,IAAI,GAAGb,oBAAoB,CAACW,KAAK,CAAC,CAAC,CAAC,CAACG,WAAW,EAAE,CAAC;IACzD,IAAIC,SAAS,GAAG,EAAE;IAClBA,SAAS,CAACF,IAAI,CAAC,GAAGD,GAAG;IAGrB,IAAII,QAAQ,GAAGL,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE;IACzCK,QAAQ,GAAGA,QAAQ,CAACF,WAAW,EAAE;IACjC,IAAI,CAACE,QAAQ,EAAE;MACX;;IAGJ,IAAI,KAAK,CAACC,IAAI,CAACD,QAAQ,CAAC,IAAI,QAAQ,CAACC,IAAI,CAACD,QAAQ,CAAC,IAAI,WAAW,CAACC,IAAI,CAACD,QAAQ,CAAC,EAAE;MAC/ED,SAAS,GAAGZ,gBAAgB,CAACY,SAAS,CAAC;;IAG3C,OAAOd,iBAAiB,CAACiB,2BAA2B,CAACR,OAAO,CAACS,SAAS,EAAEJ,SAAS,CAAC;EACtF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}