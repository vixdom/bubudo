{"ast":null,"code":"import { MONTH_DICTIONARY } from \"../constants.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nconst PATTERN = new RegExp(`([0-9]{4})[-\\\\.\\\\/\\\\s]` + `(?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[-\\\\.\\\\/\\\\s]` + `([0-9]{1,2})` + \"(?=\\\\W|$)\", \"i\");\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst MONTH_NUMBER_GROUP = 3;\nconst DATE_NUMBER_GROUP = 4;\nexport default class ENYearMonthDayParser extends AbstractParserWithWordBoundaryChecking {\n  constructor(strictMonthDateOrder) {\n    super();\n    this.strictMonthDateOrder = strictMonthDateOrder;\n  }\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const year = parseInt(match[YEAR_NUMBER_GROUP]);\n    let day = parseInt(match[DATE_NUMBER_GROUP]);\n    let month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n    if (month < 1 || month > 12) {\n      if (this.strictMonthDateOrder) {\n        return null;\n      }\n      if (day >= 1 && day <= 12) {\n        [month, day] = [day, month];\n      }\n    }\n    if (day < 1 || day > 31) {\n      return null;\n    }\n    return {\n      day: day,\n      month: month,\n      year: year\n    };\n  }\n}","map":{"version":3,"names":["MONTH_DICTIONARY","matchAnyPattern","AbstractParserWithWordBoundaryChecking","PATTERN","RegExp","YEAR_NUMBER_GROUP","MONTH_NAME_GROUP","MONTH_NUMBER_GROUP","DATE_NUMBER_GROUP","ENYearMonthDayParser","constructor","strictMonthDateOrder","innerPattern","innerExtract","context","match","year","parseInt","day","month","toLowerCase"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/en/parsers/ENYearMonthDayParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n/*\n    Date format with slash \"/\" between numbers like ENSlashDateFormatParser,\n    but this parser expect year before month and date.\n    - YYYY/MM/DD\n    - YYYY-MM-DD\n    - YYYY.MM.DD\n*/\nconst PATTERN = new RegExp(\n    `([0-9]{4})[-\\\\.\\\\/\\\\s]` +\n        `(?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[-\\\\.\\\\/\\\\s]` +\n        `([0-9]{1,2})` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst MONTH_NUMBER_GROUP = 3;\nconst DATE_NUMBER_GROUP = 4;\n\nexport default class ENYearMonthDayParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMonthDateOrder: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const year = parseInt(match[YEAR_NUMBER_GROUP]);\n        let day = parseInt(match[DATE_NUMBER_GROUP]);\n        let month = match[MONTH_NUMBER_GROUP]\n            ? parseInt(match[MONTH_NUMBER_GROUP])\n            : MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n\n        if (month < 1 || month > 12) {\n            if (this.strictMonthDateOrder) {\n                return null;\n            }\n            if (day >= 1 && day <= 12) {\n                [month, day] = [day, month];\n            }\n        }\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        return {\n            day: day,\n            month: month,\n            year: year,\n        };\n    }\n}\n"],"mappings":"AACA,SAASA,gBAAgB,QAAQ,iBAAe;AAChD,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,sCAAsC,QAAQ,2DAAyD;AAShH,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,wBAAwB,GACpB,OAAOH,eAAe,CAACD,gBAAgB,CAAC,6BAA6B,GACrE,cAAc,GACd,WAAW,EACf,GAAG,CACN;AAED,MAAMK,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,iBAAiB,GAAG,CAAC;AAE3B,eAAc,MAAOC,oBAAqB,SAAQP,sCAAsC;EACpFQ,YAAoBC,oBAA6B;IAC7C,KAAK,EAAE;IADS,KAAAA,oBAAoB,GAApBA,oBAAoB;EAExC;EAEAC,YAAYA,CAAA;IACR,OAAOT,OAAO;EAClB;EAEAU,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IACzD,MAAMC,IAAI,GAAGC,QAAQ,CAACF,KAAK,CAACV,iBAAiB,CAAC,CAAC;IAC/C,IAAIa,GAAG,GAAGD,QAAQ,CAACF,KAAK,CAACP,iBAAiB,CAAC,CAAC;IAC5C,IAAIW,KAAK,GAAGJ,KAAK,CAACR,kBAAkB,CAAC,GAC/BU,QAAQ,CAACF,KAAK,CAACR,kBAAkB,CAAC,CAAC,GACnCP,gBAAgB,CAACe,KAAK,CAACT,gBAAgB,CAAC,CAACc,WAAW,EAAE,CAAC;IAE7D,IAAID,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,EAAE,EAAE;MACzB,IAAI,IAAI,CAACR,oBAAoB,EAAE;QAC3B,OAAO,IAAI;;MAEf,IAAIO,GAAG,IAAI,CAAC,IAAIA,GAAG,IAAI,EAAE,EAAE;QACvB,CAACC,KAAK,EAAED,GAAG,CAAC,GAAG,CAACA,GAAG,EAAEC,KAAK,CAAC;;;IAGnC,IAAID,GAAG,GAAG,CAAC,IAAIA,GAAG,GAAG,EAAE,EAAE;MACrB,OAAO,IAAI;;IAGf,OAAO;MACHA,GAAG,EAAEA,GAAG;MACRC,KAAK,EAAEA,KAAK;MACZH,IAAI,EAAEA;KACT;EACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}