{"ast":null,"code":"import { findYearClosestToRef } from \"../../../calculation/years.js\";\nimport { MONTH_DICTIONARY } from \"../constants.js\";\nimport { YEAR_PATTERN, parseYear } from \"../constants.js\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nconst PATTERN = new RegExp(\"(?:on\\\\s*?)?\" + `(${ORDINAL_NUMBER_PATTERN})` + `(?:\\\\s*(?:au|\\\\-|\\\\–|jusqu'au?|\\\\s)\\\\s*(${ORDINAL_NUMBER_PATTERN}))?` + `(?:-|/|\\\\s*(?:de)?\\\\s*)` + `(${matchAnyPattern(MONTH_DICTIONARY)})` + `(?:(?:-|/|,?\\\\s*)(${YEAR_PATTERN}(?![^\\\\s]\\\\d)))?` + `(?=\\\\W|$)`, \"i\");\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\nexport default class FRMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const result = context.createParsingResult(match.index, match[0]);\n    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n    const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n    if (day > 31) {\n      match.index = match.index + match[DATE_GROUP].length;\n      return null;\n    }\n    result.start.assign(\"month\", month);\n    result.start.assign(\"day\", day);\n    if (match[YEAR_GROUP]) {\n      const yearNumber = parseYear(match[YEAR_GROUP]);\n      result.start.assign(\"year\", yearNumber);\n    } else {\n      const year = findYearClosestToRef(context.refDate, day, month);\n      result.start.imply(\"year\", year);\n    }\n    if (match[DATE_TO_GROUP]) {\n      const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n      result.end = result.start.clone();\n      result.end.assign(\"day\", endDate);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["findYearClosestToRef","MONTH_DICTIONARY","YEAR_PATTERN","parseYear","ORDINAL_NUMBER_PATTERN","parseOrdinalNumberPattern","matchAnyPattern","AbstractParserWithWordBoundaryChecking","PATTERN","RegExp","DATE_GROUP","DATE_TO_GROUP","MONTH_NAME_GROUP","YEAR_GROUP","FRMonthNameLittleEndianParser","innerPattern","innerExtract","context","match","result","createParsingResult","index","month","toLowerCase","day","length","start","assign","yearNumber","year","refDate","imply","endDate","end","clone"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/fr/parsers/FRMonthNameLittleEndianParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"(?:on\\\\s*?)?\" +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        `(?:\\\\s*(?:au|\\\\-|\\\\–|jusqu'au?|\\\\s)\\\\s*(${ORDINAL_NUMBER_PATTERN}))?` +\n        `(?:-|/|\\\\s*(?:de)?\\\\s*)` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:(?:-|/|,?\\\\s*)(${YEAR_PATTERN}(?![^\\\\s]\\\\d)))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class FRMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        //console.log(match)\n\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ,+BAA6B;AAClE,SAASC,gBAAgB,QAAQ,iBAAe;AAChD,SAASC,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AACvD,SAASC,sBAAsB,EAAEC,yBAAyB,QAAQ,iBAAe;AACjF,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,sCAAsC,QAAQ,2DAAyD;AAEhH,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,cAAc,GACV,IAAIL,sBAAsB,GAAG,GAC7B,2CAA2CA,sBAAsB,KAAK,GACtE,yBAAyB,GACzB,IAAIE,eAAe,CAACL,gBAAgB,CAAC,GAAG,GACxC,qBAAqBC,YAAY,kBAAkB,GACnD,WAAW,EACf,GAAG,CACN;AAED,MAAMQ,UAAU,GAAG,CAAC;AACpB,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,UAAU,GAAG,CAAC;AAEpB,eAAc,MAAOC,6BAA8B,SAAQP,sCAAsC;EAC7FQ,YAAYA,CAAA;IACR,OAAOP,OAAO;EAClB;EAEAQ,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IAGzD,MAAMC,MAAM,GAAGF,OAAO,CAACG,mBAAmB,CAACF,KAAK,CAACG,KAAK,EAAEH,KAAK,CAAC,CAAC,CAAC,CAAC;IAEjE,MAAMI,KAAK,GAAGrB,gBAAgB,CAACiB,KAAK,CAACN,gBAAgB,CAAC,CAACW,WAAW,EAAE,CAAC;IACrE,MAAMC,GAAG,GAAGnB,yBAAyB,CAACa,KAAK,CAACR,UAAU,CAAC,CAAC;IACxD,IAAIc,GAAG,GAAG,EAAE,EAAE;MAEVN,KAAK,CAACG,KAAK,GAAGH,KAAK,CAACG,KAAK,GAAGH,KAAK,CAACR,UAAU,CAAC,CAACe,MAAM;MACpD,OAAO,IAAI;;IAGfN,MAAM,CAACO,KAAK,CAACC,MAAM,CAAC,OAAO,EAAEL,KAAK,CAAC;IACnCH,MAAM,CAACO,KAAK,CAACC,MAAM,CAAC,KAAK,EAAEH,GAAG,CAAC;IAE/B,IAAIN,KAAK,CAACL,UAAU,CAAC,EAAE;MACnB,MAAMe,UAAU,GAAGzB,SAAS,CAACe,KAAK,CAACL,UAAU,CAAC,CAAC;MAC/CM,MAAM,CAACO,KAAK,CAACC,MAAM,CAAC,MAAM,EAAEC,UAAU,CAAC;KAC1C,MAAM;MACH,MAAMC,IAAI,GAAG7B,oBAAoB,CAACiB,OAAO,CAACa,OAAO,EAAEN,GAAG,EAAEF,KAAK,CAAC;MAC9DH,MAAM,CAACO,KAAK,CAACK,KAAK,CAAC,MAAM,EAAEF,IAAI,CAAC;;IAGpC,IAAIX,KAAK,CAACP,aAAa,CAAC,EAAE;MACtB,MAAMqB,OAAO,GAAG3B,yBAAyB,CAACa,KAAK,CAACP,aAAa,CAAC,CAAC;MAE/DQ,MAAM,CAACc,GAAG,GAAGd,MAAM,CAACO,KAAK,CAACQ,KAAK,EAAE;MACjCf,MAAM,CAACc,GAAG,CAACN,MAAM,CAAC,KAAK,EAAEK,OAAO,CAAC;;IAGrC,OAAOb,MAAM;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}