{"ast":null,"code":"import { MergingRefiner } from \"../../../common/abstractRefiners.js\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results.js\";\nimport { parseTimeUnits } from \"../constants.js\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits.js\";\nfunction IsPositiveFollowingReference(result) {\n  return result.text.match(/^[+-]/i) != null;\n}\nfunction IsNegativeFollowingReference(result) {\n  return result.text.match(/^-/i) != null;\n}\nexport default class ENMergeRelativeAfterDateRefiner extends MergingRefiner {\n  shouldMergeResults(textBetween, currentResult, nextResult) {\n    if (!textBetween.match(/^\\s*$/i)) {\n      return false;\n    }\n    return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);\n  }\n  mergeResults(textBetween, currentResult, nextResult, context) {\n    let timeUnits = parseTimeUnits(nextResult.text);\n    if (IsNegativeFollowingReference(nextResult)) {\n      timeUnits = reverseTimeUnits(timeUnits);\n    }\n    const components = ParsingComponents.createRelativeFromReference(new ReferenceWithTimezone(currentResult.start.date()), timeUnits);\n    return new ParsingResult(currentResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);\n  }\n}","map":{"version":3,"names":["MergingRefiner","ParsingComponents","ParsingResult","ReferenceWithTimezone","parseTimeUnits","reverseTimeUnits","IsPositiveFollowingReference","result","text","match","IsNegativeFollowingReference","ENMergeRelativeAfterDateRefiner","shouldMergeResults","textBetween","currentResult","nextResult","mergeResults","context","timeUnits","components","createRelativeFromReference","start","date","reference","index"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/en/refiners/ENMergeRelativeAfterDateRefiner.ts"],"sourcesContent":["import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseTimeUnits } from \"../constants\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nfunction IsPositiveFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^[+-]/i) != null;\n}\n\nfunction IsNegativeFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^-/i) != null;\n}\n\n/**\n * Merges a relative data/time that comes after an absolute date.\n * - [2020-02-13] [+2 weeks]\n * - [next tuesday] [+10 days]\n */\nexport default class ENMergeRelativeAfterDateRefiner extends MergingRefiner {\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        if (!textBetween.match(/^\\s*$/i)) {\n            return false;\n        }\n\n        return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult, context): ParsingResult {\n        let timeUnits = parseTimeUnits(nextResult.text);\n        if (IsNegativeFollowingReference(nextResult)) {\n            timeUnits = reverseTimeUnits(timeUnits);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            new ReferenceWithTimezone(currentResult.start.date()),\n            timeUnits\n        );\n\n        return new ParsingResult(\n            currentResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,qCAAmC;AAClE,SAASC,iBAAiB,EAAEC,aAAa,EAAEC,qBAAqB,QAAQ,qBAAmB;AAC3F,SAASC,cAAc,QAAQ,iBAAe;AAC9C,SAASC,gBAAgB,QAAQ,6BAA2B;AAE5D,SAASC,4BAA4BA,CAACC,MAAqB;EACvD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,QAAQ,CAAC,IAAI,IAAI;AAC9C;AAEA,SAASC,4BAA4BA,CAACH,MAAqB;EACvD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,KAAK,CAAC,IAAI,IAAI;AAC3C;AAOA,eAAc,MAAOE,+BAAgC,SAAQX,cAAc;EACvEY,kBAAkBA,CAACC,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB;IAC3F,IAAI,CAACF,WAAW,CAACJ,KAAK,CAAC,QAAQ,CAAC,EAAE;MAC9B,OAAO,KAAK;;IAGhB,OAAOH,4BAA4B,CAACS,UAAU,CAAC,IAAIL,4BAA4B,CAACK,UAAU,CAAC;EAC/F;EAEAC,YAAYA,CAACH,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB,EAAEE,OAAO;IAC9F,IAAIC,SAAS,GAAGd,cAAc,CAACW,UAAU,CAACP,IAAI,CAAC;IAC/C,IAAIE,4BAA4B,CAACK,UAAU,CAAC,EAAE;MAC1CG,SAAS,GAAGb,gBAAgB,CAACa,SAAS,CAAC;;IAG3C,MAAMC,UAAU,GAAGlB,iBAAiB,CAACmB,2BAA2B,CAC5D,IAAIjB,qBAAqB,CAACW,aAAa,CAACO,KAAK,CAACC,IAAI,EAAE,CAAC,EACrDJ,SAAS,CACZ;IAED,OAAO,IAAIhB,aAAa,CACpBY,aAAa,CAACS,SAAS,EACvBT,aAAa,CAACU,KAAK,EACnB,GAAGV,aAAa,CAACN,IAAI,GAAGK,WAAW,GAAGE,UAAU,CAACP,IAAI,EAAE,EACvDW,UAAU,CACb;EACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}