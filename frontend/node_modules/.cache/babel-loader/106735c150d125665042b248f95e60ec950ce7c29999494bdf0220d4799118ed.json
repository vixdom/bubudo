{"ast":null,"code":"import { findMostLikelyADYear, findYearClosestToRef } from \"../../calculation/years.js\";\nconst PATTERN = new RegExp(\"([^\\\\d]|^)\" + \"([0-3]{0,1}[0-9]{1})[\\\\/\\\\.\\\\-]([0-3]{0,1}[0-9]{1})\" + \"(?:[\\\\/\\\\.\\\\-]([0-9]{4}|[0-9]{2}))?\" + \"(\\\\W|$)\", \"i\");\nconst OPENING_GROUP = 1;\nconst ENDING_GROUP = 5;\nconst FIRST_NUMBERS_GROUP = 2;\nconst SECOND_NUMBERS_GROUP = 3;\nconst YEAR_GROUP = 4;\nexport default class SlashDateFormatParser {\n  constructor(littleEndian) {\n    this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;\n    this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;\n  }\n  pattern() {\n    return PATTERN;\n  }\n  extract(context, match) {\n    const index = match.index + match[OPENING_GROUP].length;\n    const indexEnd = match.index + match[0].length - match[ENDING_GROUP].length;\n    if (index > 0) {\n      const textBefore = context.text.substring(0, index);\n      if (textBefore.match(\"\\\\d/?$\")) {\n        return;\n      }\n    }\n    if (indexEnd < context.text.length) {\n      const textAfter = context.text.substring(indexEnd);\n      if (textAfter.match(\"^/?\\\\d\")) {\n        return;\n      }\n    }\n    const text = context.text.substring(index, indexEnd);\n    if (text.match(/^\\d\\.\\d$/) || text.match(/^\\d\\.\\d{1,2}\\.\\d{1,2}\\s*$/)) {\n      return;\n    }\n    if (!match[YEAR_GROUP] && text.indexOf(\"/\") < 0) {\n      return;\n    }\n    const result = context.createParsingResult(index, text);\n    let month = parseInt(match[this.groupNumberMonth]);\n    let day = parseInt(match[this.groupNumberDay]);\n    if (month < 1 || month > 12) {\n      if (month > 12) {\n        if (day >= 1 && day <= 12 && month <= 31) {\n          [day, month] = [month, day];\n        } else {\n          return null;\n        }\n      }\n    }\n    if (day < 1 || day > 31) {\n      return null;\n    }\n    result.start.assign(\"day\", day);\n    result.start.assign(\"month\", month);\n    if (match[YEAR_GROUP]) {\n      const rawYearNumber = parseInt(match[YEAR_GROUP]);\n      const year = findMostLikelyADYear(rawYearNumber);\n      result.start.assign(\"year\", year);\n    } else {\n      const year = findYearClosestToRef(context.refDate, day, month);\n      result.start.imply(\"year\", year);\n    }\n    return result.addTag(\"parser/SlashDateFormatParser\");\n  }\n}","map":{"version":3,"names":["findMostLikelyADYear","findYearClosestToRef","PATTERN","RegExp","OPENING_GROUP","ENDING_GROUP","FIRST_NUMBERS_GROUP","SECOND_NUMBERS_GROUP","YEAR_GROUP","SlashDateFormatParser","constructor","littleEndian","groupNumberMonth","groupNumberDay","pattern","extract","context","match","index","length","indexEnd","textBefore","text","substring","textAfter","indexOf","result","createParsingResult","month","parseInt","day","start","assign","rawYearNumber","year","refDate","imply","addTag"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/common/parsers/SlashDateFormatParser.ts"],"sourcesContent":["import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\nimport { findMostLikelyADYear, findYearClosestToRef } from \"../../calculation/years\";\n\n/**\n * Date format with slash \"/\" (or dot \".\") between numbers.\n * For examples:\n * - 7/10\n * - 7/12/2020\n * - 7.12.2020\n */\nconst PATTERN = new RegExp(\n    \"([^\\\\d]|^)\" +\n        \"([0-3]{0,1}[0-9]{1})[\\\\/\\\\.\\\\-]([0-3]{0,1}[0-9]{1})\" +\n        \"(?:[\\\\/\\\\.\\\\-]([0-9]{4}|[0-9]{2}))?\" +\n        \"(\\\\W|$)\",\n    \"i\"\n);\n\nconst OPENING_GROUP = 1;\nconst ENDING_GROUP = 5;\n\nconst FIRST_NUMBERS_GROUP = 2;\nconst SECOND_NUMBERS_GROUP = 3;\n\nconst YEAR_GROUP = 4;\n\nexport default class SlashDateFormatParser implements Parser {\n    groupNumberMonth: number;\n    groupNumberDay: number;\n\n    constructor(littleEndian: boolean) {\n        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;\n        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;\n    }\n\n    pattern(): RegExp {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        // Because of how pattern is executed on remaining text in `chrono.ts`, the character before the match could\n        // still be a number (e.g. X[X/YY/ZZ] or XX[/YY/ZZ] or [XX/YY/]ZZ). We want to check and skip them.\n        const index = match.index + match[OPENING_GROUP].length;\n        const indexEnd = match.index + match[0].length - match[ENDING_GROUP].length;\n        if (index > 0) {\n            const textBefore = context.text.substring(0, index);\n            if (textBefore.match(\"\\\\d/?$\")) {\n                return;\n            }\n        }\n        if (indexEnd < context.text.length) {\n            const textAfter = context.text.substring(indexEnd);\n            if (textAfter.match(\"^/?\\\\d\")) {\n                return;\n            }\n        }\n\n        const text = context.text.substring(index, indexEnd);\n\n        // '1.12', '1.12.12' is more like a version numbers\n        if (text.match(/^\\d\\.\\d$/) || text.match(/^\\d\\.\\d{1,2}\\.\\d{1,2}\\s*$/)) {\n            return;\n        }\n\n        // MM/dd -> OK\n        // MM.dd -> NG\n        if (!match[YEAR_GROUP] && text.indexOf(\"/\") < 0) {\n            return;\n        }\n\n        const result = context.createParsingResult(index, text);\n        let month = parseInt(match[this.groupNumberMonth]);\n        let day = parseInt(match[this.groupNumberDay]);\n        if (month < 1 || month > 12) {\n            if (month > 12) {\n                if (day >= 1 && day <= 12 && month <= 31) {\n                    [day, month] = [month, day];\n                } else {\n                    return null;\n                }\n            }\n        }\n\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        result.start.assign(\"day\", day);\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const rawYearNumber = parseInt(match[YEAR_GROUP]);\n            const year = findMostLikelyADYear(rawYearNumber);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result.addTag(\"parser/SlashDateFormatParser\");\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}