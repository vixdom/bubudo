{"ast":null,"code":"import { toTimezoneOffset } from \"../../timezone.js\";\nconst TIMEZONE_NAME_PATTERN = new RegExp(\"^\\\\s*,?\\\\s*\\\\(?([A-Z]{2,4})\\\\)?(?=\\\\W|$)\", \"i\");\nexport default class ExtractTimezoneAbbrRefiner {\n  constructor(timezoneOverrides) {\n    this.timezoneOverrides = timezoneOverrides;\n  }\n  refine(context, results) {\n    const timezoneOverrides = context.option.timezones ?? {};\n    results.forEach(result => {\n      const suffix = context.text.substring(result.index + result.text.length);\n      const match = TIMEZONE_NAME_PATTERN.exec(suffix);\n      if (!match) {\n        return;\n      }\n      const timezoneAbbr = match[1].toUpperCase();\n      const refDate = result.start.date() ?? result.refDate ?? new Date();\n      const tzOverrides = {\n        ...this.timezoneOverrides,\n        ...timezoneOverrides\n      };\n      const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);\n      if (extractedTimezoneOffset == null) {\n        return;\n      }\n      context.debug(() => {\n        console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);\n      });\n      const currentTimezoneOffset = result.start.get(\"timezoneOffset\");\n      if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {\n        if (result.start.isCertain(\"timezoneOffset\")) {\n          return;\n        }\n        if (timezoneAbbr != match[1]) {\n          return;\n        }\n      }\n      if (result.start.isOnlyDate()) {\n        if (timezoneAbbr != match[1]) {\n          return;\n        }\n      }\n      result.text += match[0];\n      if (!result.start.isCertain(\"timezoneOffset\")) {\n        result.start.assign(\"timezoneOffset\", extractedTimezoneOffset);\n      }\n      if (result.end != null && !result.end.isCertain(\"timezoneOffset\")) {\n        result.end.assign(\"timezoneOffset\", extractedTimezoneOffset);\n      }\n    });\n    return results;\n  }\n}","map":{"version":3,"names":["toTimezoneOffset","TIMEZONE_NAME_PATTERN","RegExp","ExtractTimezoneAbbrRefiner","constructor","timezoneOverrides","refine","context","results","option","timezones","forEach","result","suffix","text","substring","index","length","match","exec","timezoneAbbr","toUpperCase","refDate","start","date","Date","tzOverrides","extractedTimezoneOffset","debug","console","log","currentTimezoneOffset","get","isCertain","isOnlyDate","assign","end"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/common/refiners/ExtractTimezoneAbbrRefiner.ts"],"sourcesContent":["// Map ABBR -> Offset in minute\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { TimezoneAbbrMap } from \"../../types\";\nimport { ParsingResult } from \"../../results\";\nimport { toTimezoneOffset } from \"../../timezone\";\n\nconst TIMEZONE_NAME_PATTERN = new RegExp(\"^\\\\s*,?\\\\s*\\\\(?([A-Z]{2,4})\\\\)?(?=\\\\W|$)\", \"i\");\n\nexport default class ExtractTimezoneAbbrRefiner implements Refiner {\n    constructor(private readonly timezoneOverrides?: TimezoneAbbrMap) {}\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        const timezoneOverrides = context.option.timezones ?? {};\n\n        results.forEach((result) => {\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = TIMEZONE_NAME_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n\n            const timezoneAbbr = match[1].toUpperCase();\n            const refDate = result.start.date() ?? result.refDate ?? new Date();\n            const tzOverrides = { ...this.timezoneOverrides, ...timezoneOverrides };\n            const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);\n            if (extractedTimezoneOffset == null) {\n                return;\n            }\n            context.debug(() => {\n                console.log(\n                    `Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`\n                );\n            });\n\n            const currentTimezoneOffset = result.start.get(\"timezoneOffset\");\n            if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {\n                // We may already have extracted the timezone offset e.g. \"11 am GMT+0900 (JST)\"\n                // - if they are equal, we also want to take the abbreviation text into result\n                // - if they are not equal, we trust the offset more\n                if (result.start.isCertain(\"timezoneOffset\")) {\n                    return;\n                }\n\n                // This is often because it's relative time with inferred timezone (e.g. in 1 hour, tomorrow)\n                // Then, we want to double-check the abbr case (e.g. \"GET\" not \"get\")\n                if (timezoneAbbr != match[1]) {\n                    return;\n                }\n            }\n\n            if (result.start.isOnlyDate()) {\n                // If the time is not explicitly mentioned,\n                // Then, we also want to double-check the abbr case (e.g. \"GET\" not \"get\")\n                if (timezoneAbbr != match[1]) {\n                    return;\n                }\n            }\n\n            result.text += match[0];\n\n            if (!result.start.isCertain(\"timezoneOffset\")) {\n                result.start.assign(\"timezoneOffset\", extractedTimezoneOffset);\n            }\n\n            if (result.end != null && !result.end.isCertain(\"timezoneOffset\")) {\n                result.end.assign(\"timezoneOffset\", extractedTimezoneOffset);\n            }\n        });\n\n        return results;\n    }\n}\n"],"mappings":"AAIA,SAASA,gBAAgB,QAAQ,mBAAiB;AAElD,MAAMC,qBAAqB,GAAG,IAAIC,MAAM,CAAC,0CAA0C,EAAE,GAAG,CAAC;AAEzF,eAAc,MAAOC,0BAA0B;EAC3CC,YAA6BC,iBAAmC;IAAnC,KAAAA,iBAAiB,GAAjBA,iBAAiB;EAAqB;EAEnEC,MAAMA,CAACC,OAAuB,EAAEC,OAAwB;IACpD,MAAMH,iBAAiB,GAAGE,OAAO,CAACE,MAAM,CAACC,SAAS,IAAI,EAAE;IAExDF,OAAO,CAACG,OAAO,CAAEC,MAAM,IAAI;MACvB,MAAMC,MAAM,GAAGN,OAAO,CAACO,IAAI,CAACC,SAAS,CAACH,MAAM,CAACI,KAAK,GAAGJ,MAAM,CAACE,IAAI,CAACG,MAAM,CAAC;MACxE,MAAMC,KAAK,GAAGjB,qBAAqB,CAACkB,IAAI,CAACN,MAAM,CAAC;MAChD,IAAI,CAACK,KAAK,EAAE;QACR;;MAGJ,MAAME,YAAY,GAAGF,KAAK,CAAC,CAAC,CAAC,CAACG,WAAW,EAAE;MAC3C,MAAMC,OAAO,GAAGV,MAAM,CAACW,KAAK,CAACC,IAAI,EAAE,IAAIZ,MAAM,CAACU,OAAO,IAAI,IAAIG,IAAI,EAAE;MACnE,MAAMC,WAAW,GAAG;QAAE,GAAG,IAAI,CAACrB,iBAAiB;QAAE,GAAGA;MAAiB,CAAE;MACvE,MAAMsB,uBAAuB,GAAG3B,gBAAgB,CAACoB,YAAY,EAAEE,OAAO,EAAEI,WAAW,CAAC;MACpF,IAAIC,uBAAuB,IAAI,IAAI,EAAE;QACjC;;MAEJpB,OAAO,CAACqB,KAAK,CAAC,MAAK;QACfC,OAAO,CAACC,GAAG,CACP,yBAAyBV,YAAY,WAAWO,uBAAuB,SAASf,MAAM,CAACW,KAAK,EAAE,CACjG;MACL,CAAC,CAAC;MAEF,MAAMQ,qBAAqB,GAAGnB,MAAM,CAACW,KAAK,CAACS,GAAG,CAAC,gBAAgB,CAAC;MAChE,IAAID,qBAAqB,KAAK,IAAI,IAAIJ,uBAAuB,IAAII,qBAAqB,EAAE;QAIpF,IAAInB,MAAM,CAACW,KAAK,CAACU,SAAS,CAAC,gBAAgB,CAAC,EAAE;UAC1C;;QAKJ,IAAIb,YAAY,IAAIF,KAAK,CAAC,CAAC,CAAC,EAAE;UAC1B;;;MAIR,IAAIN,MAAM,CAACW,KAAK,CAACW,UAAU,EAAE,EAAE;QAG3B,IAAId,YAAY,IAAIF,KAAK,CAAC,CAAC,CAAC,EAAE;UAC1B;;;MAIRN,MAAM,CAACE,IAAI,IAAII,KAAK,CAAC,CAAC,CAAC;MAEvB,IAAI,CAACN,MAAM,CAACW,KAAK,CAACU,SAAS,CAAC,gBAAgB,CAAC,EAAE;QAC3CrB,MAAM,CAACW,KAAK,CAACY,MAAM,CAAC,gBAAgB,EAAER,uBAAuB,CAAC;;MAGlE,IAAIf,MAAM,CAACwB,GAAG,IAAI,IAAI,IAAI,CAACxB,MAAM,CAACwB,GAAG,CAACH,SAAS,CAAC,gBAAgB,CAAC,EAAE;QAC/DrB,MAAM,CAACwB,GAAG,CAACD,MAAM,CAAC,gBAAgB,EAAER,uBAAuB,CAAC;;IAEpE,CAAC,CAAC;IAEF,OAAOnB,OAAO;EAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}