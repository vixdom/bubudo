{"ast":null,"code":"import { Meridiem } from \"../../../types.js\";\nconst FIRST_REG_PATTERN = new RegExp(\"(^|\\\\s|T)\" + \"(?:(?:[àa])\\\\s*)?\" + \"(\\\\d{1,2})(?:h|:)?\" + \"(?:(\\\\d{1,2})(?:m|:)?)?\" + \"(?:(\\\\d{1,2})(?:s|:)?)?\" + \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?))?\" + \"(?=\\\\W|$)\", \"i\");\nconst SECOND_REG_PATTERN = new RegExp(\"^\\\\s*(\\\\-|\\\\–|\\\\~|\\\\〜|[àa]|\\\\?)\\\\s*\" + \"(\\\\d{1,2})(?:h|:)?\" + \"(?:(\\\\d{1,2})(?:m|:)?)?\" + \"(?:(\\\\d{1,2})(?:s|:)?)?\" + \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?))?\" + \"(?=\\\\W|$)\", \"i\");\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst AM_PM_HOUR_GROUP = 5;\nexport default class FRSpecificTimeExpressionParser {\n  pattern(context) {\n    return FIRST_REG_PATTERN;\n  }\n  extract(context, match) {\n    const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));\n    if (result.text.match(/^\\d{4}$/)) {\n      match.index += match[0].length;\n      return null;\n    }\n    result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);\n    if (!result.start) {\n      match.index += match[0].length;\n      return null;\n    }\n    const remainingText = context.text.substring(match.index + match[0].length);\n    const secondMatch = SECOND_REG_PATTERN.exec(remainingText);\n    if (secondMatch) {\n      result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);\n      if (result.end) {\n        result.text += secondMatch[0];\n      }\n    }\n    return result;\n  }\n  static extractTimeComponent(extractingComponents, match) {\n    let hour = 0;\n    let minute = 0;\n    let meridiem = null;\n    hour = parseInt(match[HOUR_GROUP]);\n    if (match[MINUTE_GROUP] != null) {\n      minute = parseInt(match[MINUTE_GROUP]);\n    }\n    if (minute >= 60 || hour > 24) {\n      return null;\n    }\n    if (hour >= 12) {\n      meridiem = Meridiem.PM;\n    }\n    if (match[AM_PM_HOUR_GROUP] != null) {\n      if (hour > 12) return null;\n      const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n      if (ampm == \"a\") {\n        meridiem = Meridiem.AM;\n        if (hour == 12) {\n          hour = 0;\n        }\n      }\n      if (ampm == \"p\") {\n        meridiem = Meridiem.PM;\n        if (hour != 12) {\n          hour += 12;\n        }\n      }\n    }\n    extractingComponents.assign(\"hour\", hour);\n    extractingComponents.assign(\"minute\", minute);\n    if (meridiem !== null) {\n      extractingComponents.assign(\"meridiem\", meridiem);\n    } else {\n      if (hour < 12) {\n        extractingComponents.imply(\"meridiem\", Meridiem.AM);\n      } else {\n        extractingComponents.imply(\"meridiem\", Meridiem.PM);\n      }\n    }\n    if (match[SECOND_GROUP] != null) {\n      const second = parseInt(match[SECOND_GROUP]);\n      if (second >= 60) return null;\n      extractingComponents.assign(\"second\", second);\n    }\n    return extractingComponents;\n  }\n}","map":{"version":3,"names":["Meridiem","FIRST_REG_PATTERN","RegExp","SECOND_REG_PATTERN","HOUR_GROUP","MINUTE_GROUP","SECOND_GROUP","AM_PM_HOUR_GROUP","FRSpecificTimeExpressionParser","pattern","context","extract","match","result","createParsingResult","index","length","substring","text","start","extractTimeComponent","clone","remainingText","secondMatch","exec","end","extractingComponents","hour","minute","meridiem","parseInt","PM","ampm","toLowerCase","AM","assign","imply","second"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/fr/parsers/FRSpecificTimeExpressionParser.ts"],"sourcesContent":["import { Parser, ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\n\n/**\n * 8h10m00s\n * 8h10m00\n * 8h10\n */\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(^|\\\\s|T)\" +\n        \"(?:(?:[àa])\\\\s*)?\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s|:)?)?\" +\n        \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"^\\\\s*(\\\\-|\\\\–|\\\\~|\\\\〜|[àa]|\\\\?)\\\\s*\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s|:)?)?\" +\n        \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst AM_PM_HOUR_GROUP = 5;\n\nexport default class FRSpecificTimeExpressionParser implements Parser {\n    pattern(context): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult | null {\n        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));\n\n        // This looks more like a year e.g. 2020\n        if (result.text.match(/^\\d{4}$/)) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);\n        if (!result.start) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        const remainingText = context.text.substring(match.index + match[0].length);\n        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);\n        if (secondMatch) {\n            result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);\n            if (result.end) {\n                result.text += secondMatch[0];\n            }\n        }\n\n        return result;\n    }\n\n    private static extractTimeComponent(\n        extractingComponents: ParsingComponents,\n        match: RegExpMatchArray\n    ): ParsingComponents | null {\n        let hour = 0;\n        let minute = 0;\n        let meridiem = null;\n\n        // ----- Hours\n        hour = parseInt(match[HOUR_GROUP]);\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP] != null) {\n            minute = parseInt(match[MINUTE_GROUP]);\n        }\n\n        if (minute >= 60 || hour > 24) {\n            return null;\n        }\n\n        if (hour >= 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) {\n                    hour += 12;\n                }\n            }\n        }\n\n        extractingComponents.assign(\"hour\", hour);\n        extractingComponents.assign(\"minute\", minute);\n        if (meridiem !== null) {\n            extractingComponents.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                extractingComponents.imply(\"meridiem\", Meridiem.AM);\n            } else {\n                extractingComponents.imply(\"meridiem\", Meridiem.PM);\n            }\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            extractingComponents.assign(\"second\", second);\n        }\n\n        return extractingComponents;\n    }\n}\n"],"mappings":"AAEA,SAASA,QAAQ,QAAQ,mBAAiB;AAO1C,MAAMC,iBAAiB,GAAG,IAAIC,MAAM,CAChC,WAAW,GACP,mBAAmB,GACnB,oBAAoB,GACpB,yBAAyB,GACzB,yBAAyB,GACzB,sCAAsC,GACtC,WAAW,EACf,GAAG,CACN;AAED,MAAMC,kBAAkB,GAAG,IAAID,MAAM,CACjC,qCAAqC,GACjC,oBAAoB,GACpB,yBAAyB,GACzB,yBAAyB,GACzB,sCAAsC,GACtC,WAAW,EACf,GAAG,CACN;AAED,MAAME,UAAU,GAAG,CAAC;AACpB,MAAMC,YAAY,GAAG,CAAC;AACtB,MAAMC,YAAY,GAAG,CAAC;AACtB,MAAMC,gBAAgB,GAAG,CAAC;AAE1B,eAAc,MAAOC,8BAA8B;EAC/CC,OAAOA,CAACC,OAAO;IACX,OAAOT,iBAAiB;EAC5B;EAEAU,OAAOA,CAACD,OAAuB,EAAEE,KAAuB;IACpD,MAAMC,MAAM,GAAGH,OAAO,CAACI,mBAAmB,CAACF,KAAK,CAACG,KAAK,GAAGH,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,EAAEJ,KAAK,CAAC,CAAC,CAAC,CAACK,SAAS,CAACL,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,CAAC,CAAC;IAG9G,IAAIH,MAAM,CAACK,IAAI,CAACN,KAAK,CAAC,SAAS,CAAC,EAAE;MAC9BA,KAAK,CAACG,KAAK,IAAIH,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM;MAC9B,OAAO,IAAI;;IAGfH,MAAM,CAACM,KAAK,GAAGX,8BAA8B,CAACY,oBAAoB,CAACP,MAAM,CAACM,KAAK,CAACE,KAAK,EAAE,EAAET,KAAK,CAAC;IAC/F,IAAI,CAACC,MAAM,CAACM,KAAK,EAAE;MACfP,KAAK,CAACG,KAAK,IAAIH,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM;MAC9B,OAAO,IAAI;;IAGf,MAAMM,aAAa,GAAGZ,OAAO,CAACQ,IAAI,CAACD,SAAS,CAACL,KAAK,CAACG,KAAK,GAAGH,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,CAAC;IAC3E,MAAMO,WAAW,GAAGpB,kBAAkB,CAACqB,IAAI,CAACF,aAAa,CAAC;IAC1D,IAAIC,WAAW,EAAE;MACbV,MAAM,CAACY,GAAG,GAAGjB,8BAA8B,CAACY,oBAAoB,CAACP,MAAM,CAACM,KAAK,CAACE,KAAK,EAAE,EAAEE,WAAW,CAAC;MACnG,IAAIV,MAAM,CAACY,GAAG,EAAE;QACZZ,MAAM,CAACK,IAAI,IAAIK,WAAW,CAAC,CAAC,CAAC;;;IAIrC,OAAOV,MAAM;EACjB;EAEQ,OAAOO,oBAAoBA,CAC/BM,oBAAuC,EACvCd,KAAuB;IAEvB,IAAIe,IAAI,GAAG,CAAC;IACZ,IAAIC,MAAM,GAAG,CAAC;IACd,IAAIC,QAAQ,GAAG,IAAI;IAGnBF,IAAI,GAAGG,QAAQ,CAAClB,KAAK,CAACR,UAAU,CAAC,CAAC;IAGlC,IAAIQ,KAAK,CAACP,YAAY,CAAC,IAAI,IAAI,EAAE;MAC7BuB,MAAM,GAAGE,QAAQ,CAAClB,KAAK,CAACP,YAAY,CAAC,CAAC;;IAG1C,IAAIuB,MAAM,IAAI,EAAE,IAAID,IAAI,GAAG,EAAE,EAAE;MAC3B,OAAO,IAAI;;IAGf,IAAIA,IAAI,IAAI,EAAE,EAAE;MACZE,QAAQ,GAAG7B,QAAQ,CAAC+B,EAAE;;IAI1B,IAAInB,KAAK,CAACL,gBAAgB,CAAC,IAAI,IAAI,EAAE;MACjC,IAAIoB,IAAI,GAAG,EAAE,EAAE,OAAO,IAAI;MAC1B,MAAMK,IAAI,GAAGpB,KAAK,CAACL,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC0B,WAAW,EAAE;MACrD,IAAID,IAAI,IAAI,GAAG,EAAE;QACbH,QAAQ,GAAG7B,QAAQ,CAACkC,EAAE;QACtB,IAAIP,IAAI,IAAI,EAAE,EAAE;UACZA,IAAI,GAAG,CAAC;;;MAIhB,IAAIK,IAAI,IAAI,GAAG,EAAE;QACbH,QAAQ,GAAG7B,QAAQ,CAAC+B,EAAE;QACtB,IAAIJ,IAAI,IAAI,EAAE,EAAE;UACZA,IAAI,IAAI,EAAE;;;;IAKtBD,oBAAoB,CAACS,MAAM,CAAC,MAAM,EAAER,IAAI,CAAC;IACzCD,oBAAoB,CAACS,MAAM,CAAC,QAAQ,EAAEP,MAAM,CAAC;IAC7C,IAAIC,QAAQ,KAAK,IAAI,EAAE;MACnBH,oBAAoB,CAACS,MAAM,CAAC,UAAU,EAAEN,QAAQ,CAAC;KACpD,MAAM;MACH,IAAIF,IAAI,GAAG,EAAE,EAAE;QACXD,oBAAoB,CAACU,KAAK,CAAC,UAAU,EAAEpC,QAAQ,CAACkC,EAAE,CAAC;OACtD,MAAM;QACHR,oBAAoB,CAACU,KAAK,CAAC,UAAU,EAAEpC,QAAQ,CAAC+B,EAAE,CAAC;;;IAK3D,IAAInB,KAAK,CAACN,YAAY,CAAC,IAAI,IAAI,EAAE;MAC7B,MAAM+B,MAAM,GAAGP,QAAQ,CAAClB,KAAK,CAACN,YAAY,CAAC,CAAC;MAC5C,IAAI+B,MAAM,IAAI,EAAE,EAAE,OAAO,IAAI;MAE7BX,oBAAoB,CAACS,MAAM,CAAC,QAAQ,EAAEE,MAAM,CAAC;;IAGjD,OAAOX,oBAAoB;EAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}