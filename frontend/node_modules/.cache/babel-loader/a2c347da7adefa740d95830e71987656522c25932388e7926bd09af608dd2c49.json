{"ast":null,"code":"import { findYearClosestToRef } from \"../../../calculation/years.js\";\nimport { MONTH_DICTIONARY } from \"../constants.js\";\nimport { YEAR_PATTERN, parseYear } from \"../constants.js\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking.js\";\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\nexport default class RUMonthNameLittleEndianParser extends AbstractParserWithLeftRightBoundaryChecking {\n  innerPatternString(context) {\n    return `(?:с)?\\\\s*(${ORDINAL_NUMBER_PATTERN})` + `(?:` + `\\\\s{0,3}(?:по|-|–|до)?\\\\s{0,3}` + `(${ORDINAL_NUMBER_PATTERN})` + `)?` + `(?:-|\\\\/|\\\\s{0,3}(?:of)?\\\\s{0,3})` + `(${matchAnyPattern(MONTH_DICTIONARY)})` + `(?:` + `(?:-|\\\\/|,?\\\\s{0,3})` + `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` + `)?`;\n  }\n  innerExtract(context, match) {\n    const result = context.createParsingResult(match.index, match[0]);\n    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n    const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n    if (day > 31) {\n      match.index = match.index + match[DATE_GROUP].length;\n      return null;\n    }\n    result.start.assign(\"month\", month);\n    result.start.assign(\"day\", day);\n    if (match[YEAR_GROUP]) {\n      const yearNumber = parseYear(match[YEAR_GROUP]);\n      result.start.assign(\"year\", yearNumber);\n    } else {\n      const year = findYearClosestToRef(context.refDate, day, month);\n      result.start.imply(\"year\", year);\n    }\n    if (match[DATE_TO_GROUP]) {\n      const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n      result.end = result.start.clone();\n      result.end.assign(\"day\", endDate);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["findYearClosestToRef","MONTH_DICTIONARY","YEAR_PATTERN","parseYear","ORDINAL_NUMBER_PATTERN","parseOrdinalNumberPattern","matchAnyPattern","AbstractParserWithLeftRightBoundaryChecking","DATE_GROUP","DATE_TO_GROUP","MONTH_NAME_GROUP","YEAR_GROUP","RUMonthNameLittleEndianParser","innerPatternString","context","innerExtract","match","result","createParsingResult","index","month","toLowerCase","day","length","start","assign","yearNumber","year","refDate","imply","endDate","end","clone"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/ru/parsers/RUMonthNameLittleEndianParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class RUMonthNameLittleEndianParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        // prettier-ignore\n        return `(?:с)?\\\\s*(${ORDINAL_NUMBER_PATTERN})` +\n            `(?:` +\n                `\\\\s{0,3}(?:по|-|–|до)?\\\\s{0,3}` +\n                `(${ORDINAL_NUMBER_PATTERN})` +\n            `)?` +\n                `(?:-|\\\\/|\\\\s{0,3}(?:of)?\\\\s{0,3})` +\n                `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `(?:` +\n                `(?:-|\\\\/|,?\\\\s{0,3})` +\n                `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` +\n            `)?`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ,+BAA6B;AAClE,SAASC,gBAAgB,QAAQ,iBAAe;AAChD,SAASC,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AACvD,SAASC,sBAAsB,EAAEC,yBAAyB,QAAQ,iBAAe;AACjF,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,2CAA2C,QAAQ,6CAA2C;AAEvG,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,UAAU,GAAG,CAAC;AAEpB,eAAc,MAAOC,6BAA8B,SAAQL,2CAA2C;EAClGM,kBAAkBA,CAACC,OAAuB;IAEtC,OAAO,cAAcV,sBAAsB,GAAG,GAC1C,KAAK,GACD,gCAAgC,GAChC,IAAIA,sBAAsB,GAAG,GACjC,IAAI,GACA,mCAAmC,GACnC,IAAIE,eAAe,CAACL,gBAAgB,CAAC,GAAG,GAC5C,KAAK,GACD,sBAAsB,GACtB,IAAIC,YAAY,gBAAgB,GACpC,IAAI;EACZ;EAEAa,YAAYA,CAACD,OAAuB,EAAEE,KAAuB;IACzD,MAAMC,MAAM,GAAGH,OAAO,CAACI,mBAAmB,CAACF,KAAK,CAACG,KAAK,EAAEH,KAAK,CAAC,CAAC,CAAC,CAAC;IAEjE,MAAMI,KAAK,GAAGnB,gBAAgB,CAACe,KAAK,CAACN,gBAAgB,CAAC,CAACW,WAAW,EAAE,CAAC;IACrE,MAAMC,GAAG,GAAGjB,yBAAyB,CAACW,KAAK,CAACR,UAAU,CAAC,CAAC;IACxD,IAAIc,GAAG,GAAG,EAAE,EAAE;MAEVN,KAAK,CAACG,KAAK,GAAGH,KAAK,CAACG,KAAK,GAAGH,KAAK,CAACR,UAAU,CAAC,CAACe,MAAM;MACpD,OAAO,IAAI;;IAGfN,MAAM,CAACO,KAAK,CAACC,MAAM,CAAC,OAAO,EAAEL,KAAK,CAAC;IACnCH,MAAM,CAACO,KAAK,CAACC,MAAM,CAAC,KAAK,EAAEH,GAAG,CAAC;IAE/B,IAAIN,KAAK,CAACL,UAAU,CAAC,EAAE;MACnB,MAAMe,UAAU,GAAGvB,SAAS,CAACa,KAAK,CAACL,UAAU,CAAC,CAAC;MAC/CM,MAAM,CAACO,KAAK,CAACC,MAAM,CAAC,MAAM,EAAEC,UAAU,CAAC;KAC1C,MAAM;MACH,MAAMC,IAAI,GAAG3B,oBAAoB,CAACc,OAAO,CAACc,OAAO,EAAEN,GAAG,EAAEF,KAAK,CAAC;MAC9DH,MAAM,CAACO,KAAK,CAACK,KAAK,CAAC,MAAM,EAAEF,IAAI,CAAC;;IAGpC,IAAIX,KAAK,CAACP,aAAa,CAAC,EAAE;MACtB,MAAMqB,OAAO,GAAGzB,yBAAyB,CAACW,KAAK,CAACP,aAAa,CAAC,CAAC;MAE/DQ,MAAM,CAACc,GAAG,GAAGd,MAAM,CAACO,KAAK,CAACQ,KAAK,EAAE;MACjCf,MAAM,CAACc,GAAG,CAACN,MAAM,CAAC,KAAK,EAAEK,OAAO,CAAC;;IAGrC,OAAOb,MAAM;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}