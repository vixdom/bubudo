{"ast":null,"code":"import { WEEKDAY_DICTIONARY } from \"../constants.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays.js\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking.js\";\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\nexport default class UKWeekdayParser extends AbstractParserWithLeftRightBoundaryChecking {\n  innerPatternString(context) {\n    return `(?:(?:,|\\\\(|（)\\\\s*)?` + `(?:в\\\\s*?)?` + `(?:у\\\\s*?)?` + `(?:(цей|минулого|минулий|попередній|попереднього|наступного|наступний|наступному)\\\\s*)?` + `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` + `(?:\\\\s*(?:,|\\\\)|）))?` + `(?:\\\\s*(на|у|в)\\\\s*(цьому|минулому|наступному)\\\\s*тижні)?`;\n  }\n  innerExtract(context, match) {\n    const dayOfWeek = match[WEEKDAY_GROUP].toLocaleLowerCase();\n    const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n    const prefix = match[PREFIX_GROUP];\n    const postfix = match[POSTFIX_GROUP];\n    let modifierWord = prefix || postfix;\n    modifierWord = modifierWord || \"\";\n    modifierWord = modifierWord.toLocaleLowerCase();\n    let modifier = null;\n    if (modifierWord == \"минулого\" || modifierWord == \"минулий\" || modifierWord == \"попередній\" || modifierWord == \"попереднього\") {\n      modifier = \"last\";\n    } else if (modifierWord == \"наступного\" || modifierWord == \"наступний\") {\n      modifier = \"next\";\n    } else if (modifierWord == \"цей\" || modifierWord == \"цього\" || modifierWord == \"цьому\") {\n      modifier = \"this\";\n    }\n    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n  }\n}","map":{"version":3,"names":["WEEKDAY_DICTIONARY","matchAnyPattern","createParsingComponentsAtWeekday","AbstractParserWithLeftRightBoundaryChecking","PREFIX_GROUP","WEEKDAY_GROUP","POSTFIX_GROUP","UKWeekdayParser","innerPatternString","context","innerExtract","match","dayOfWeek","toLocaleLowerCase","weekday","prefix","postfix","modifierWord","modifier","reference"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/uk/parsers/UKWeekdayParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\n// TODO: ADD REGEX_PARTS below\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class UKWeekdayParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `(?:(?:,|\\\\(|（)\\\\s*)?` +\n            `(?:в\\\\s*?)?` +\n            `(?:у\\\\s*?)?` +\n            `(?:(цей|минулого|минулий|попередній|попереднього|наступного|наступний|наступному)\\\\s*)?` +\n            `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n            `(?:\\\\s*(?:,|\\\\)|）))?` +\n            `(?:\\\\s*(на|у|в)\\\\s*(цьому|минулому|наступному)\\\\s*тижні)?`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLocaleLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLocaleLowerCase();\n\n        let modifier = null;\n        if (\n            modifierWord == \"минулого\" ||\n            modifierWord == \"минулий\" ||\n            modifierWord == \"попередній\" ||\n            modifierWord == \"попереднього\"\n        ) {\n            modifier = \"last\";\n        } else if (modifierWord == \"наступного\" || modifierWord == \"наступний\") {\n            modifier = \"next\";\n        } else if (modifierWord == \"цей\" || modifierWord == \"цього\" || modifierWord == \"цьому\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n"],"mappings":"AAGA,SAASA,kBAAkB,QAAQ,iBAAe;AAClD,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,gCAAgC,QAAQ,yCAAuC;AACxF,SAASC,2CAA2C,QAAQ,6CAA2C;AAEvG,MAAMC,YAAY,GAAG,CAAC;AACtB,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,aAAa,GAAG,CAAC;AAEvB,eAAc,MAAOC,eAAgB,SAAQJ,2CAA2C;EACpFK,kBAAkBA,CAACC,OAAuB;IACtC,OACI,sBAAsB,GACtB,aAAa,GACb,aAAa,GACb,yFAAyF,GACzF,IAAIR,eAAe,CAACD,kBAAkB,CAAC,GAAG,GAC1C,sBAAsB,GACtB,2DAA2D;EAEnE;EAEAU,YAAYA,CAACD,OAAuB,EAAEE,KAAuB;IACzD,MAAMC,SAAS,GAAGD,KAAK,CAACN,aAAa,CAAC,CAACQ,iBAAiB,EAAE;IAC1D,MAAMC,OAAO,GAAGd,kBAAkB,CAACY,SAAS,CAAC;IAC7C,MAAMG,MAAM,GAAGJ,KAAK,CAACP,YAAY,CAAC;IAClC,MAAMY,OAAO,GAAGL,KAAK,CAACL,aAAa,CAAC;IACpC,IAAIW,YAAY,GAAGF,MAAM,IAAIC,OAAO;IACpCC,YAAY,GAAGA,YAAY,IAAI,EAAE;IACjCA,YAAY,GAAGA,YAAY,CAACJ,iBAAiB,EAAE;IAE/C,IAAIK,QAAQ,GAAG,IAAI;IACnB,IACID,YAAY,IAAI,UAAU,IAC1BA,YAAY,IAAI,SAAS,IACzBA,YAAY,IAAI,YAAY,IAC5BA,YAAY,IAAI,cAAc,EAChC;MACEC,QAAQ,GAAG,MAAM;KACpB,MAAM,IAAID,YAAY,IAAI,YAAY,IAAIA,YAAY,IAAI,WAAW,EAAE;MACpEC,QAAQ,GAAG,MAAM;KACpB,MAAM,IAAID,YAAY,IAAI,KAAK,IAAIA,YAAY,IAAI,OAAO,IAAIA,YAAY,IAAI,OAAO,EAAE;MACpFC,QAAQ,GAAG,MAAM;;IAGrB,OAAOhB,gCAAgC,CAACO,OAAO,CAACU,SAAS,EAAEL,OAAO,EAAEI,QAAQ,CAAC;EACjF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}