{"ast":null,"code":"import { ReferenceWithTimezone, ParsingComponents, ParsingResult } from \"./results.js\";\nimport ENDefaultConfiguration from \"./locales/en/configuration.js\";\nexport class Chrono {\n  constructor(configuration) {\n    this.defaultConfig = new ENDefaultConfiguration();\n    configuration = configuration || this.defaultConfig.createCasualConfiguration();\n    this.parsers = [...configuration.parsers];\n    this.refiners = [...configuration.refiners];\n  }\n  clone() {\n    return new Chrono({\n      parsers: [...this.parsers],\n      refiners: [...this.refiners]\n    });\n  }\n  parseDate(text, referenceDate, option) {\n    const results = this.parse(text, referenceDate, option);\n    return results.length > 0 ? results[0].start.date() : null;\n  }\n  parse(text, referenceDate, option) {\n    const context = new ParsingContext(text, referenceDate, option);\n    let results = [];\n    this.parsers.forEach(parser => {\n      const parsedResults = Chrono.executeParser(context, parser);\n      results = results.concat(parsedResults);\n    });\n    results.sort((a, b) => {\n      return a.index - b.index;\n    });\n    this.refiners.forEach(function (refiner) {\n      results = refiner.refine(context, results);\n    });\n    return results;\n  }\n  static executeParser(context, parser) {\n    const results = [];\n    const pattern = parser.pattern(context);\n    const originalText = context.text;\n    let remainingText = context.text;\n    let match = pattern.exec(remainingText);\n    while (match) {\n      const index = match.index + originalText.length - remainingText.length;\n      match.index = index;\n      const result = parser.extract(context, match);\n      if (!result) {\n        remainingText = originalText.substring(match.index + 1);\n        match = pattern.exec(remainingText);\n        continue;\n      }\n      let parsedResult = null;\n      if (result instanceof ParsingResult) {\n        parsedResult = result;\n      } else if (result instanceof ParsingComponents) {\n        parsedResult = context.createParsingResult(match.index, match[0]);\n        parsedResult.start = result;\n      } else {\n        parsedResult = context.createParsingResult(match.index, match[0], result);\n      }\n      const parsedIndex = parsedResult.index;\n      const parsedText = parsedResult.text;\n      context.debug(() => console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`));\n      results.push(parsedResult);\n      remainingText = originalText.substring(parsedIndex + parsedText.length);\n      match = pattern.exec(remainingText);\n    }\n    return results;\n  }\n}\nexport class ParsingContext {\n  constructor(text, refDate, option) {\n    this.text = text;\n    this.reference = new ReferenceWithTimezone(refDate);\n    this.option = option ?? {};\n    this.refDate = this.reference.instant;\n  }\n  createParsingComponents(components) {\n    if (components instanceof ParsingComponents) {\n      return components;\n    }\n    return new ParsingComponents(this.reference, components);\n  }\n  createParsingResult(index, textOrEndIndex, startComponents, endComponents) {\n    const text = typeof textOrEndIndex === \"string\" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);\n    const start = startComponents ? this.createParsingComponents(startComponents) : null;\n    const end = endComponents ? this.createParsingComponents(endComponents) : null;\n    return new ParsingResult(this.reference, index, text, start, end);\n  }\n  debug(block) {\n    if (this.option.debug) {\n      if (this.option.debug instanceof Function) {\n        this.option.debug(block);\n      } else {\n        const handler = this.option.debug;\n        handler.debug(block);\n      }\n    }\n  }\n}","map":{"version":3,"names":["ReferenceWithTimezone","ParsingComponents","ParsingResult","ENDefaultConfiguration","Chrono","constructor","configuration","defaultConfig","createCasualConfiguration","parsers","refiners","clone","parseDate","text","referenceDate","option","results","parse","length","start","date","context","ParsingContext","forEach","parser","parsedResults","executeParser","concat","sort","a","b","index","refiner","refine","pattern","originalText","remainingText","match","exec","result","extract","substring","parsedResult","createParsingResult","parsedIndex","parsedText","debug","console","log","name","push","refDate","reference","instant","createParsingComponents","components","textOrEndIndex","startComponents","endComponents","end","block","Function","handler"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/chrono.ts"],"sourcesContent":["import { ReferenceWithTimezone, ParsingComponents, ParsingResult } from \"./results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference } from \"./types\";\nimport { AsyncDebugBlock, DebugHandler } from \"./debugging\";\nimport ENDefaultConfiguration from \"./locales/en/configuration\";\n\n/**\n * Chrono configuration.\n * It is simply an ordered list of parsers and refiners\n */\nexport interface Configuration {\n    parsers: Parser[];\n    refiners: Refiner[];\n}\n\n/**\n * An abstraction for Chrono *Parser*.\n *\n * Each parser should recognize and handle a certain date format.\n * Chrono uses multiple parses (and refiners) together for parsing the input.\n *\n * The parser implementation must provide {@Link pattern | pattern()} for the date format.\n *\n * The {@Link extract | extract()} method is called with the pattern's *match*.\n * The matching and extracting is controlled and adjusted to avoid for overlapping results.\n */\nexport interface Parser {\n    pattern(context: ParsingContext): RegExp;\n    extract(\n        context: ParsingContext,\n        match: RegExpMatchArray\n    ): ParsingComponents | ParsingResult | { [c in Component]?: number } | null;\n}\n\n/**\n * A abstraction for Chrono *Refiner*.\n *\n * Each refiner takes the list of results (from parsers or other refiners) and returns another list of results.\n * Chrono applies each refiner in order and return the output from the last refiner.\n */\nexport interface Refiner {\n    refine: (context: ParsingContext, results: ParsingResult[]) => ParsingResult[];\n}\n\n/**\n * The Chrono object.\n */\nexport class Chrono {\n    parsers: Array<Parser>;\n    refiners: Array<Refiner>;\n\n    defaultConfig = new ENDefaultConfiguration();\n\n    constructor(configuration?: Configuration) {\n        configuration = configuration || this.defaultConfig.createCasualConfiguration();\n        this.parsers = [...configuration.parsers];\n        this.refiners = [...configuration.refiners];\n    }\n\n    /**\n     * Create a shallow copy of the Chrono object with the same configuration (`parsers` and `refiners`)\n     */\n    clone(): Chrono {\n        return new Chrono({\n            parsers: [...this.parsers],\n            refiners: [...this.refiners],\n        });\n    }\n\n    /**\n     * A shortcut for calling {@Link parse | parse() } then transform the result into Javascript's Date object\n     * @return Date object created from the first parse result\n     */\n    parseDate(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): Date | null {\n        const results = this.parse(text, referenceDate, option);\n        return results.length > 0 ? results[0].start.date() : null;\n    }\n\n    parse(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n        const context = new ParsingContext(text, referenceDate, option);\n\n        let results = [];\n        this.parsers.forEach((parser) => {\n            const parsedResults = Chrono.executeParser(context, parser);\n            results = results.concat(parsedResults);\n        });\n\n        results.sort((a, b) => {\n            return a.index - b.index;\n        });\n\n        this.refiners.forEach(function (refiner) {\n            results = refiner.refine(context, results);\n        });\n\n        return results;\n    }\n\n    private static executeParser(context: ParsingContext, parser: Parser) {\n        const results = [];\n        const pattern = parser.pattern(context);\n\n        const originalText = context.text;\n        let remainingText = context.text;\n        let match = pattern.exec(remainingText);\n\n        while (match) {\n            // Calculate match index on the full text;\n            const index = match.index + originalText.length - remainingText.length;\n            match.index = index;\n\n            const result = parser.extract(context, match);\n            if (!result) {\n                // If fails, move on by 1\n                remainingText = originalText.substring(match.index + 1);\n                match = pattern.exec(remainingText);\n                continue;\n            }\n\n            let parsedResult: ParsingResult = null;\n            if (result instanceof ParsingResult) {\n                parsedResult = result;\n            } else if (result instanceof ParsingComponents) {\n                parsedResult = context.createParsingResult(match.index, match[0]);\n                parsedResult.start = result;\n            } else {\n                parsedResult = context.createParsingResult(match.index, match[0], result);\n            }\n\n            const parsedIndex = parsedResult.index;\n            const parsedText = parsedResult.text;\n            context.debug(() =>\n                console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`)\n            );\n\n            results.push(parsedResult);\n            remainingText = originalText.substring(parsedIndex + parsedText.length);\n            match = pattern.exec(remainingText);\n        }\n\n        return results;\n    }\n}\n\nexport class ParsingContext implements DebugHandler {\n    readonly text: string;\n    readonly option: ParsingOption;\n    readonly reference: ReferenceWithTimezone;\n\n    /**\n     * @deprecated. Use `reference.instant` instead.\n     */\n    readonly refDate: Date;\n\n    constructor(text: string, refDate?: ParsingReference | Date, option?: ParsingOption) {\n        this.text = text;\n        this.reference = new ReferenceWithTimezone(refDate);\n        this.option = option ?? {};\n\n        this.refDate = this.reference.instant;\n    }\n\n    createParsingComponents(components?: { [c in Component]?: number } | ParsingComponents): ParsingComponents {\n        if (components instanceof ParsingComponents) {\n            return components;\n        }\n\n        return new ParsingComponents(this.reference, components);\n    }\n\n    createParsingResult(\n        index: number,\n        textOrEndIndex: number | string,\n        startComponents?: { [c in Component]?: number } | ParsingComponents,\n        endComponents?: { [c in Component]?: number } | ParsingComponents\n    ): ParsingResult {\n        const text = typeof textOrEndIndex === \"string\" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);\n\n        const start = startComponents ? this.createParsingComponents(startComponents) : null;\n        const end = endComponents ? this.createParsingComponents(endComponents) : null;\n\n        return new ParsingResult(this.reference, index, text, start, end);\n    }\n\n    debug(block: AsyncDebugBlock): void {\n        if (this.option.debug) {\n            if (this.option.debug instanceof Function) {\n                this.option.debug(block);\n            } else {\n                const handler: DebugHandler = <DebugHandler>this.option.debug;\n                handler.debug(block);\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}