{"ast":null,"code":"import { toHankaku } from \"../constants.js\";\nimport { findYearClosestToRef } from \"../../../calculation/years.js\";\nimport dayjs from \"dayjs\";\nconst PATTERN = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\\s*)?([0-9０-９]{1,2})月\\s*([0-9０-９]{1,2})日/i;\nconst SPECIAL_YEAR_GROUP = 1;\nconst TYPICAL_YEAR_GROUP = 2;\nconst ERA_GROUP = 3;\nconst YEAR_NUMBER_GROUP = 4;\nconst MONTH_GROUP = 5;\nconst DAY_GROUP = 6;\nexport default class JPStandardParser {\n  pattern() {\n    return PATTERN;\n  }\n  extract(context, match) {\n    const month = parseInt(toHankaku(match[MONTH_GROUP]));\n    const day = parseInt(toHankaku(match[DAY_GROUP]));\n    const components = context.createParsingComponents({\n      day: day,\n      month: month\n    });\n    if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match(\"同|今|本\")) {\n      const moment = dayjs(context.refDate);\n      components.assign(\"year\", moment.year());\n    }\n    if (match[TYPICAL_YEAR_GROUP]) {\n      const yearNumText = match[YEAR_NUMBER_GROUP];\n      let year = yearNumText == \"元\" ? 1 : parseInt(toHankaku(yearNumText));\n      if (match[ERA_GROUP] == \"令和\") {\n        year += 2018;\n      } else if (match[ERA_GROUP] == \"平成\") {\n        year += 1988;\n      } else if (match[ERA_GROUP] == \"昭和\") {\n        year += 1925;\n      }\n      components.assign(\"year\", year);\n    } else {\n      const year = findYearClosestToRef(context.refDate, day, month);\n      components.imply(\"year\", year);\n    }\n    return components;\n  }\n}","map":{"version":3,"names":["toHankaku","findYearClosestToRef","dayjs","PATTERN","SPECIAL_YEAR_GROUP","TYPICAL_YEAR_GROUP","ERA_GROUP","YEAR_NUMBER_GROUP","MONTH_GROUP","DAY_GROUP","JPStandardParser","pattern","extract","context","match","month","parseInt","day","components","createParsingComponents","moment","refDate","assign","year","yearNumText","imply"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/ja/parsers/JPStandardParser.ts"],"sourcesContent":["import { Parser, ParsingContext } from \"../../../chrono\";\nimport { toHankaku } from \"../constants\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\n\nimport dayjs from \"dayjs\";\n\nconst PATTERN =\n    /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\\s*)?([0-9０-９]{1,2})月\\s*([0-9０-９]{1,2})日/i;\nconst SPECIAL_YEAR_GROUP = 1;\nconst TYPICAL_YEAR_GROUP = 2;\nconst ERA_GROUP = 3;\nconst YEAR_NUMBER_GROUP = 4;\nconst MONTH_GROUP = 5;\nconst DAY_GROUP = 6;\n\nexport default class JPStandardParser implements Parser {\n    pattern() {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = parseInt(toHankaku(match[MONTH_GROUP]));\n        const day = parseInt(toHankaku(match[DAY_GROUP]));\n        const components = context.createParsingComponents({\n            day: day,\n            month: month,\n        });\n\n        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match(\"同|今|本\")) {\n            const moment = dayjs(context.refDate);\n            components.assign(\"year\", moment.year());\n        }\n\n        if (match[TYPICAL_YEAR_GROUP]) {\n            const yearNumText = match[YEAR_NUMBER_GROUP];\n\n            let year = yearNumText == \"元\" ? 1 : parseInt(toHankaku(yearNumText));\n            if (match[ERA_GROUP] == \"令和\") {\n                year += 2018;\n            } else if (match[ERA_GROUP] == \"平成\") {\n                year += 1988;\n            } else if (match[ERA_GROUP] == \"昭和\") {\n                year += 1925;\n            }\n\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n\n        return components;\n    }\n}\n"],"mappings":"AACA,SAASA,SAAS,QAAQ,iBAAe;AACzC,SAASC,oBAAoB,QAAQ,+BAA6B;AAElE,OAAOC,KAAK,MAAM,OAAO;AAEzB,MAAMC,OAAO,GACT,yFAAyF;AAC7F,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,SAAS,GAAG,CAAC;AACnB,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,WAAW,GAAG,CAAC;AACrB,MAAMC,SAAS,GAAG,CAAC;AAEnB,eAAc,MAAOC,gBAAgB;EACjCC,OAAOA,CAAA;IACH,OAAOR,OAAO;EAClB;EAEAS,OAAOA,CAACC,OAAuB,EAAEC,KAAuB;IACpD,MAAMC,KAAK,GAAGC,QAAQ,CAAChB,SAAS,CAACc,KAAK,CAACN,WAAW,CAAC,CAAC,CAAC;IACrD,MAAMS,GAAG,GAAGD,QAAQ,CAAChB,SAAS,CAACc,KAAK,CAACL,SAAS,CAAC,CAAC,CAAC;IACjD,MAAMS,UAAU,GAAGL,OAAO,CAACM,uBAAuB,CAAC;MAC/CF,GAAG,EAAEA,GAAG;MACRF,KAAK,EAAEA;KACV,CAAC;IAEF,IAAID,KAAK,CAACV,kBAAkB,CAAC,IAAIU,KAAK,CAACV,kBAAkB,CAAC,CAACU,KAAK,CAAC,OAAO,CAAC,EAAE;MACvE,MAAMM,MAAM,GAAGlB,KAAK,CAACW,OAAO,CAACQ,OAAO,CAAC;MACrCH,UAAU,CAACI,MAAM,CAAC,MAAM,EAAEF,MAAM,CAACG,IAAI,EAAE,CAAC;;IAG5C,IAAIT,KAAK,CAACT,kBAAkB,CAAC,EAAE;MAC3B,MAAMmB,WAAW,GAAGV,KAAK,CAACP,iBAAiB,CAAC;MAE5C,IAAIgB,IAAI,GAAGC,WAAW,IAAI,GAAG,GAAG,CAAC,GAAGR,QAAQ,CAAChB,SAAS,CAACwB,WAAW,CAAC,CAAC;MACpE,IAAIV,KAAK,CAACR,SAAS,CAAC,IAAI,IAAI,EAAE;QAC1BiB,IAAI,IAAI,IAAI;OACf,MAAM,IAAIT,KAAK,CAACR,SAAS,CAAC,IAAI,IAAI,EAAE;QACjCiB,IAAI,IAAI,IAAI;OACf,MAAM,IAAIT,KAAK,CAACR,SAAS,CAAC,IAAI,IAAI,EAAE;QACjCiB,IAAI,IAAI,IAAI;;MAGhBL,UAAU,CAACI,MAAM,CAAC,MAAM,EAAEC,IAAI,CAAC;KAClC,MAAM;MACH,MAAMA,IAAI,GAAGtB,oBAAoB,CAACY,OAAO,CAACQ,OAAO,EAAEJ,GAAG,EAAEF,KAAK,CAAC;MAC9DG,UAAU,CAACO,KAAK,CAAC,MAAM,EAAEF,IAAI,CAAC;;IAGlC,OAAOL,UAAU;EACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}