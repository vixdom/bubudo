{"ast":null,"code":"import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants.js\";\nimport { findYearClosestToRef } from \"../../../calculation/years.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { YEAR_PATTERN, parseYear } from \"../constants.js\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nconst PATTERN = new RegExp(`((?:in)\\\\s*)?` + `(${matchAnyPattern(MONTH_DICTIONARY)})` + `\\\\s*` + `(?:` + `(?:,|-|of)?\\\\s*(${YEAR_PATTERN})?` + \")?\" + \"(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)\", \"i\");\nconst PREFIX_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\nexport default class ENMonthNameParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n    if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n      return null;\n    }\n    const result = context.createParsingResult(match.index + (match[PREFIX_GROUP] || \"\").length, match.index + match[0].length);\n    result.start.imply(\"day\", 1);\n    result.start.addTag(\"parser/ENMonthNameParser\");\n    const month = MONTH_DICTIONARY[monthName];\n    result.start.assign(\"month\", month);\n    if (match[YEAR_GROUP]) {\n      const year = parseYear(match[YEAR_GROUP]);\n      result.start.assign(\"year\", year);\n    } else {\n      const year = findYearClosestToRef(context.refDate, 1, month);\n      result.start.imply(\"year\", year);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["FULL_MONTH_NAME_DICTIONARY","MONTH_DICTIONARY","findYearClosestToRef","matchAnyPattern","YEAR_PATTERN","parseYear","AbstractParserWithWordBoundaryChecking","PATTERN","RegExp","PREFIX_GROUP","MONTH_NAME_GROUP","YEAR_GROUP","ENMonthNameParser","innerPattern","innerExtract","context","match","monthName","toLowerCase","length","result","createParsingResult","index","start","imply","addTag","month","assign","year","refDate"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/en/parsers/ENMonthNameParser.ts"],"sourcesContent":["import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `((?:in)\\\\s*)?` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `\\\\s*` +\n        `(?:` +\n        `(?:,|-|of)?\\\\s*(${YEAR_PATTERN})?` +\n        \")?\" +\n        \"(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - January, 2012\n * - January 2012\n * - January\n * (in) Jan\n */\nexport default class ENMonthNameParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"jan\", \"mar\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(\n            match.index + (match[PREFIX_GROUP] || \"\").length,\n            match.index + match[0].length\n        );\n        result.start.imply(\"day\", 1);\n        result.start.addTag(\"parser/ENMonthNameParser\");\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n"],"mappings":"AAAA,SAASA,0BAA0B,EAAEC,gBAAgB,QAAQ,iBAAe;AAE5E,SAASC,oBAAoB,QAAQ,+BAA6B;AAClE,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AACvD,SAASC,sCAAsC,QAAQ,2DAAyD;AAEhH,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,eAAe,GACX,IAAIL,eAAe,CAACF,gBAAgB,CAAC,GAAG,GACxC,MAAM,GACN,KAAK,GACL,mBAAmBG,YAAY,IAAI,GACnC,IAAI,GACJ,kCAAkC,EACtC,GAAG,CACN;AAED,MAAMK,YAAY,GAAG,CAAC;AACtB,MAAMC,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,UAAU,GAAG,CAAC;AASpB,eAAc,MAAOC,iBAAkB,SAAQN,sCAAsC;EACjFO,YAAYA,CAAA;IACR,OAAON,OAAO;EAClB;EAEAO,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IACzD,MAAMC,SAAS,GAAGD,KAAK,CAACN,gBAAgB,CAAC,CAACQ,WAAW,EAAE;IAGvD,IAAIF,KAAK,CAAC,CAAC,CAAC,CAACG,MAAM,IAAI,CAAC,IAAI,CAACnB,0BAA0B,CAACiB,SAAS,CAAC,EAAE;MAChE,OAAO,IAAI;;IAGf,MAAMG,MAAM,GAAGL,OAAO,CAACM,mBAAmB,CACtCL,KAAK,CAACM,KAAK,GAAG,CAACN,KAAK,CAACP,YAAY,CAAC,IAAI,EAAE,EAAEU,MAAM,EAChDH,KAAK,CAACM,KAAK,GAAGN,KAAK,CAAC,CAAC,CAAC,CAACG,MAAM,CAChC;IACDC,MAAM,CAACG,KAAK,CAACC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;IAC5BJ,MAAM,CAACG,KAAK,CAACE,MAAM,CAAC,0BAA0B,CAAC;IAE/C,MAAMC,KAAK,GAAGzB,gBAAgB,CAACgB,SAAS,CAAC;IACzCG,MAAM,CAACG,KAAK,CAACI,MAAM,CAAC,OAAO,EAAED,KAAK,CAAC;IAEnC,IAAIV,KAAK,CAACL,UAAU,CAAC,EAAE;MACnB,MAAMiB,IAAI,GAAGvB,SAAS,CAACW,KAAK,CAACL,UAAU,CAAC,CAAC;MACzCS,MAAM,CAACG,KAAK,CAACI,MAAM,CAAC,MAAM,EAAEC,IAAI,CAAC;KACpC,MAAM;MACH,MAAMA,IAAI,GAAG1B,oBAAoB,CAACa,OAAO,CAACc,OAAO,EAAE,CAAC,EAAEH,KAAK,CAAC;MAC5DN,MAAM,CAACG,KAAK,CAACC,KAAK,CAAC,MAAM,EAAEI,IAAI,CAAC;;IAGpC,OAAOR,MAAM;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}