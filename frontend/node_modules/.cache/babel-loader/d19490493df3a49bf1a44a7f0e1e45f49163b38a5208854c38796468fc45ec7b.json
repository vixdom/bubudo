{"ast":null,"code":"import dayjs from \"dayjs\";\nimport * as dates from \"../../utils/dates.js\";\nexport default class ForwardDateRefiner {\n  refine(context, results) {\n    if (!context.option.forwardDate) {\n      return results;\n    }\n    results.forEach(result => {\n      let refMoment = dayjs(context.reference.getDateWithAdjustedTimezone());\n      if (result.start.isOnlyTime() && context.reference.instant > result.start.date()) {\n        const refDate = context.reference.getDateWithAdjustedTimezone();\n        const refFollowingDay = new Date(refDate);\n        refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n        dates.implySimilarDate(result.start, refFollowingDay);\n        context.debug(() => {\n          console.log(`${this.constructor.name} adjusted ${result} time from the ref date (${refDate}) to the following day (${refFollowingDay})`);\n        });\n        if (result.end && result.end.isOnlyTime()) {\n          dates.implySimilarDate(result.end, refFollowingDay);\n          if (result.start.date() > result.end.date()) {\n            refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n            dates.implySimilarDate(result.end, refFollowingDay);\n          }\n        }\n      }\n      if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {\n        if (refMoment.day() >= result.start.get(\"weekday\")) {\n          refMoment = refMoment.day(result.start.get(\"weekday\") + 7);\n        } else {\n          refMoment = refMoment.day(result.start.get(\"weekday\"));\n        }\n        result.start.imply(\"day\", refMoment.date());\n        result.start.imply(\"month\", refMoment.month() + 1);\n        result.start.imply(\"year\", refMoment.year());\n        context.debug(() => {\n          console.log(`${this.constructor.name} adjusted ${result} weekday (${result.start})`);\n        });\n        if (result.end && result.end.isOnlyWeekdayComponent()) {\n          if (refMoment.day() > result.end.get(\"weekday\")) {\n            refMoment = refMoment.day(result.end.get(\"weekday\") + 7);\n          } else {\n            refMoment = refMoment.day(result.end.get(\"weekday\"));\n          }\n          result.end.imply(\"day\", refMoment.date());\n          result.end.imply(\"month\", refMoment.month() + 1);\n          result.end.imply(\"year\", refMoment.year());\n          context.debug(() => {\n            console.log(`${this.constructor.name} adjusted ${result} weekday (${result.end})`);\n          });\n        }\n      }\n      if (result.start.isDateWithUnknownYear() && refMoment.isAfter(result.start.dayjs())) {\n        for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {\n          result.start.imply(\"year\", result.start.get(\"year\") + 1);\n          context.debug(() => {\n            console.log(`${this.constructor.name} adjusted ${result} year (${result.start})`);\n          });\n          if (result.end && !result.end.isCertain(\"year\")) {\n            result.end.imply(\"year\", result.end.get(\"year\") + 1);\n            context.debug(() => {\n              console.log(`${this.constructor.name} adjusted ${result} month (${result.start})`);\n            });\n          }\n        }\n      }\n    });\n    return results;\n  }\n}","map":{"version":3,"names":["dayjs","dates","ForwardDateRefiner","refine","context","results","option","forwardDate","forEach","result","refMoment","reference","getDateWithAdjustedTimezone","start","isOnlyTime","instant","date","refDate","refFollowingDay","Date","setDate","getDate","implySimilarDate","debug","console","log","constructor","name","end","isOnlyWeekdayComponent","isAfter","day","get","imply","month","year","isDateWithUnknownYear","i","isCertain"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/common/refiners/ForwardDateRefiner.ts"],"sourcesContent":["/*\n    Enforce 'forwardDate' option to on the results. When there are missing component,\n    e.g. \"March 12-13 (without year)\" or \"Thursday\", the refiner will try to adjust the result\n    into the future instead of the past.\n*/\n\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\nimport dayjs from \"dayjs\";\nimport { implySimilarDate } from \"../../utils/dayjs\";\nimport * as dates from \"../../utils/dates\";\n\nexport default class ForwardDateRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (!context.option.forwardDate) {\n            return results;\n        }\n\n        results.forEach((result) => {\n            let refMoment = dayjs(context.reference.getDateWithAdjustedTimezone());\n\n            if (result.start.isOnlyTime() && context.reference.instant > result.start.date()) {\n                const refDate = context.reference.getDateWithAdjustedTimezone();\n                const refFollowingDay = new Date(refDate);\n                refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n\n                dates.implySimilarDate(result.start, refFollowingDay);\n                context.debug(() => {\n                    console.log(\n                        `${this.constructor.name} adjusted ${result} time from the ref date (${refDate}) to the following day (${refFollowingDay})`\n                    );\n                });\n                if (result.end && result.end.isOnlyTime()) {\n                    dates.implySimilarDate(result.end, refFollowingDay);\n                    if (result.start.date() > result.end.date()) {\n                        refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n                        dates.implySimilarDate(result.end, refFollowingDay);\n                    }\n                }\n            }\n\n            if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {\n                if (refMoment.day() >= result.start.get(\"weekday\")) {\n                    refMoment = refMoment.day(result.start.get(\"weekday\") + 7);\n                } else {\n                    refMoment = refMoment.day(<number>result.start.get(\"weekday\"));\n                }\n\n                result.start.imply(\"day\", refMoment.date());\n                result.start.imply(\"month\", refMoment.month() + 1);\n                result.start.imply(\"year\", refMoment.year());\n                context.debug(() => {\n                    console.log(`${this.constructor.name} adjusted ${result} weekday (${result.start})`);\n                });\n\n                if (result.end && result.end.isOnlyWeekdayComponent()) {\n                    // Adjust date to the coming week\n                    if (refMoment.day() > result.end.get(\"weekday\")) {\n                        refMoment = refMoment.day(result.end.get(\"weekday\") + 7);\n                    } else {\n                        refMoment = refMoment.day(<number>result.end.get(\"weekday\"));\n                    }\n\n                    result.end.imply(\"day\", refMoment.date());\n                    result.end.imply(\"month\", refMoment.month() + 1);\n                    result.end.imply(\"year\", refMoment.year());\n                    context.debug(() => {\n                        console.log(`${this.constructor.name} adjusted ${result} weekday (${result.end})`);\n                    });\n                }\n            }\n\n            // In case where we know the month, but not which year (e.g. \"in December\", \"25th December\"),\n            // try move to another year\n            if (result.start.isDateWithUnknownYear() && refMoment.isAfter(result.start.dayjs())) {\n                for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {\n                    result.start.imply(\"year\", result.start.get(\"year\") + 1);\n                    context.debug(() => {\n                        console.log(`${this.constructor.name} adjusted ${result} year (${result.start})`);\n                    });\n\n                    if (result.end && !result.end.isCertain(\"year\")) {\n                        result.end.imply(\"year\", result.end.get(\"year\") + 1);\n                        context.debug(() => {\n                            console.log(`${this.constructor.name} adjusted ${result} month (${result.start})`);\n                        });\n                    }\n                }\n            }\n        });\n\n        return results;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}