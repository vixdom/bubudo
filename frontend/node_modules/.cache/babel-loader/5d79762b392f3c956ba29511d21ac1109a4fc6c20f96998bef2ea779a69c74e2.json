{"ast":null,"code":"import dayjs from \"dayjs\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nimport { assignSimilarDate } from \"../../../utils/dayjs.js\";\nimport * as references from \"../../../common/casualReferences.js\";\nconst PATTERN = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\\s*night)(?=\\W|$)/i;\nexport default class ENCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern(context) {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    let targetDate = dayjs(context.refDate);\n    const lowerText = match[0].toLowerCase();\n    let component = context.createParsingComponents();\n    switch (lowerText) {\n      case \"now\":\n        component = references.now(context.reference);\n        break;\n      case \"today\":\n        component = references.today(context.reference);\n        break;\n      case \"yesterday\":\n        component = references.yesterday(context.reference);\n        break;\n      case \"tomorrow\":\n      case \"tmr\":\n      case \"tmrw\":\n        component = references.tomorrow(context.reference);\n        break;\n      case \"tonight\":\n        component = references.tonight(context.reference);\n        break;\n      case \"overmorrow\":\n        component = references.theDayAfter(context.reference, 2);\n        break;\n      default:\n        if (lowerText.match(/last\\s*night/)) {\n          if (targetDate.hour() > 6) {\n            targetDate = targetDate.add(-1, \"day\");\n          }\n          assignSimilarDate(component, targetDate);\n          component.imply(\"hour\", 0);\n        }\n        break;\n    }\n    component.addTag(\"parser/ENCasualDateParser\");\n    return component;\n  }\n}","map":{"version":3,"names":["dayjs","AbstractParserWithWordBoundaryChecking","assignSimilarDate","references","PATTERN","ENCasualDateParser","innerPattern","context","innerExtract","match","targetDate","refDate","lowerText","toLowerCase","component","createParsingComponents","now","reference","today","yesterday","tomorrow","tonight","theDayAfter","hour","add","imply","addTag"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/en/parsers/ENCasualDateParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate } from \"../../../utils/dayjs\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\\s*night)(?=\\W|$)/i;\n\nexport default class ENCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        let targetDate = dayjs(context.refDate);\n        const lowerText = match[0].toLowerCase();\n        let component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"now\":\n                component = references.now(context.reference);\n                break;\n\n            case \"today\":\n                component = references.today(context.reference);\n                break;\n\n            case \"yesterday\":\n                component = references.yesterday(context.reference);\n                break;\n\n            case \"tomorrow\":\n            case \"tmr\":\n            case \"tmrw\":\n                component = references.tomorrow(context.reference);\n                break;\n\n            case \"tonight\":\n                component = references.tonight(context.reference);\n                break;\n\n            case \"overmorrow\":\n                component = references.theDayAfter(context.reference, 2);\n                break;\n\n            default:\n                if (lowerText.match(/last\\s*night/)) {\n                    if (targetDate.hour() > 6) {\n                        targetDate = targetDate.add(-1, \"day\");\n                    }\n\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 0);\n                }\n                break;\n        }\n        component.addTag(\"parser/ENCasualDateParser\");\n        return component;\n    }\n}\n"],"mappings":"AAEA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,sCAAsC,QAAQ,2DAAyD;AAChH,SAASC,iBAAiB,QAAQ,yBAAuB;AACzD,OAAO,KAAKC,UAAU,MAAM,qCAAmC;AAE/D,MAAMC,OAAO,GAAG,kFAAkF;AAElG,eAAc,MAAOC,kBAAmB,SAAQJ,sCAAsC;EAClFK,YAAYA,CAACC,OAAuB;IAChC,OAAOH,OAAO;EAClB;EAEAI,YAAYA,CAACD,OAAuB,EAAEE,KAAuB;IACzD,IAAIC,UAAU,GAAGV,KAAK,CAACO,OAAO,CAACI,OAAO,CAAC;IACvC,MAAMC,SAAS,GAAGH,KAAK,CAAC,CAAC,CAAC,CAACI,WAAW,EAAE;IACxC,IAAIC,SAAS,GAAGP,OAAO,CAACQ,uBAAuB,EAAE;IAEjD,QAAQH,SAAS;MACb,KAAK,KAAK;QACNE,SAAS,GAAGX,UAAU,CAACa,GAAG,CAACT,OAAO,CAACU,SAAS,CAAC;QAC7C;MAEJ,KAAK,OAAO;QACRH,SAAS,GAAGX,UAAU,CAACe,KAAK,CAACX,OAAO,CAACU,SAAS,CAAC;QAC/C;MAEJ,KAAK,WAAW;QACZH,SAAS,GAAGX,UAAU,CAACgB,SAAS,CAACZ,OAAO,CAACU,SAAS,CAAC;QACnD;MAEJ,KAAK,UAAU;MACf,KAAK,KAAK;MACV,KAAK,MAAM;QACPH,SAAS,GAAGX,UAAU,CAACiB,QAAQ,CAACb,OAAO,CAACU,SAAS,CAAC;QAClD;MAEJ,KAAK,SAAS;QACVH,SAAS,GAAGX,UAAU,CAACkB,OAAO,CAACd,OAAO,CAACU,SAAS,CAAC;QACjD;MAEJ,KAAK,YAAY;QACbH,SAAS,GAAGX,UAAU,CAACmB,WAAW,CAACf,OAAO,CAACU,SAAS,EAAE,CAAC,CAAC;QACxD;MAEJ;QACI,IAAIL,SAAS,CAACH,KAAK,CAAC,cAAc,CAAC,EAAE;UACjC,IAAIC,UAAU,CAACa,IAAI,EAAE,GAAG,CAAC,EAAE;YACvBb,UAAU,GAAGA,UAAU,CAACc,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;;UAG1CtB,iBAAiB,CAACY,SAAS,EAAEJ,UAAU,CAAC;UACxCI,SAAS,CAACW,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC;;QAE9B;;IAERX,SAAS,CAACY,MAAM,CAAC,2BAA2B,CAAC;IAC7C,OAAOZ,SAAS;EACpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}