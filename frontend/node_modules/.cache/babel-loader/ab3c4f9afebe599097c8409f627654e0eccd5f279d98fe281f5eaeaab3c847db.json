{"ast":null,"code":"import { YEAR_PATTERN, parseYear } from \"../constants.js\";\nconst YEAR_SUFFIX_PATTERN = new RegExp(`^\\\\s*(${YEAR_PATTERN})`, \"i\");\nconst YEAR_GROUP = 1;\nexport default class ENExtractYearSuffixRefiner {\n  refine(context, results) {\n    results.forEach(function (result) {\n      if (!result.start.isDateWithUnknownYear()) {\n        return;\n      }\n      const suffix = context.text.substring(result.index + result.text.length);\n      const match = YEAR_SUFFIX_PATTERN.exec(suffix);\n      if (!match) {\n        return;\n      }\n      context.debug(() => {\n        console.log(`Extracting year: '${match[0]}' into : ${result}`);\n      });\n      const year = parseYear(match[YEAR_GROUP]);\n      if (result.end != null) {\n        result.end.assign(\"year\", year);\n      }\n      result.start.assign(\"year\", year);\n      result.text += match[0];\n    });\n    return results;\n  }\n}","map":{"version":3,"names":["YEAR_PATTERN","parseYear","YEAR_SUFFIX_PATTERN","RegExp","YEAR_GROUP","ENExtractYearSuffixRefiner","refine","context","results","forEach","result","start","isDateWithUnknownYear","suffix","text","substring","index","length","match","exec","debug","console","log","year","end","assign"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/en/refiners/ENExtractYearSuffixRefiner.ts"],"sourcesContent":["import { ParsingContext, Refiner } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\n\nconst YEAR_SUFFIX_PATTERN = new RegExp(`^\\\\s*(${YEAR_PATTERN})`, \"i\");\nconst YEAR_GROUP = 1;\nexport default class ENExtractYearSuffixRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        results.forEach(function (result) {\n            if (!result.start.isDateWithUnknownYear()) {\n                return;\n            }\n\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = YEAR_SUFFIX_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n\n            context.debug(() => {\n                console.log(`Extracting year: '${match[0]}' into : ${result}`);\n            });\n\n            const year = parseYear(match[YEAR_GROUP]);\n            if (result.end != null) {\n                result.end.assign(\"year\", year);\n            }\n            result.start.assign(\"year\", year);\n            result.text += match[0];\n        });\n\n        return results;\n    }\n}\n"],"mappings":"AAEA,SAASA,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AAEvD,MAAMC,mBAAmB,GAAG,IAAIC,MAAM,CAAC,SAASH,YAAY,GAAG,EAAE,GAAG,CAAC;AACrE,MAAMI,UAAU,GAAG,CAAC;AACpB,eAAc,MAAOC,0BAA0B;EAC3CC,MAAMA,CAACC,OAAuB,EAAEC,OAAwB;IACpDA,OAAO,CAACC,OAAO,CAAC,UAAUC,MAAM;MAC5B,IAAI,CAACA,MAAM,CAACC,KAAK,CAACC,qBAAqB,EAAE,EAAE;QACvC;;MAGJ,MAAMC,MAAM,GAAGN,OAAO,CAACO,IAAI,CAACC,SAAS,CAACL,MAAM,CAACM,KAAK,GAAGN,MAAM,CAACI,IAAI,CAACG,MAAM,CAAC;MACxE,MAAMC,KAAK,GAAGhB,mBAAmB,CAACiB,IAAI,CAACN,MAAM,CAAC;MAC9C,IAAI,CAACK,KAAK,EAAE;QACR;;MAGJX,OAAO,CAACa,KAAK,CAAC,MAAK;QACfC,OAAO,CAACC,GAAG,CAAC,qBAAqBJ,KAAK,CAAC,CAAC,CAAC,YAAYR,MAAM,EAAE,CAAC;MAClE,CAAC,CAAC;MAEF,MAAMa,IAAI,GAAGtB,SAAS,CAACiB,KAAK,CAACd,UAAU,CAAC,CAAC;MACzC,IAAIM,MAAM,CAACc,GAAG,IAAI,IAAI,EAAE;QACpBd,MAAM,CAACc,GAAG,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;;MAEnCb,MAAM,CAACC,KAAK,CAACc,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;MACjCb,MAAM,CAACI,IAAI,IAAII,KAAK,CAAC,CAAC,CAAC;IAC3B,CAAC,CAAC;IAEF,OAAOV,OAAO;EAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}