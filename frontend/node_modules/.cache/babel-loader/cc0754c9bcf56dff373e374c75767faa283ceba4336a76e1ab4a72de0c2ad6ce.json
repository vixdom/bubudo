{"ast":null,"code":"import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants.js\";\nimport { findYearClosestToRef } from \"../../../calculation/years.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { YEAR_PATTERN, parseYear } from \"../constants.js\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking.js\";\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\nexport default class RUMonthNameParser extends AbstractParserWithLeftBoundaryChecking {\n  innerPatternString(context) {\n    return `((?:в)\\\\s*)?` + `(${matchAnyPattern(MONTH_DICTIONARY)})` + `\\\\s*` + `(?:` + `[,-]?\\\\s*(${YEAR_PATTERN})?` + `)?` + `(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)`;\n  }\n  innerExtract(context, match) {\n    const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n    if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n      return null;\n    }\n    const result = context.createParsingResult(match.index, match.index + match[0].length);\n    result.start.imply(\"day\", 1);\n    const month = MONTH_DICTIONARY[monthName];\n    result.start.assign(\"month\", month);\n    if (match[YEAR_GROUP]) {\n      const year = parseYear(match[YEAR_GROUP]);\n      result.start.assign(\"year\", year);\n    } else {\n      const year = findYearClosestToRef(context.refDate, 1, month);\n      result.start.imply(\"year\", year);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["FULL_MONTH_NAME_DICTIONARY","MONTH_DICTIONARY","findYearClosestToRef","matchAnyPattern","YEAR_PATTERN","parseYear","AbstractParserWithLeftBoundaryChecking","MONTH_NAME_GROUP","YEAR_GROUP","RUMonthNameParser","innerPatternString","context","innerExtract","match","monthName","toLowerCase","length","result","createParsingResult","index","start","imply","month","assign","year","refDate"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/locales/ru/parsers/RUMonthNameParser.ts"],"sourcesContent":["import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - Январь, 2012\n * - Январь 2012\n * - Январь\n */\nexport default class RUMonthNameParser extends AbstractParserWithLeftBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `((?:в)\\\\s*)?` +\n            `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `\\\\s*` +\n            `(?:` +\n            `[,-]?\\\\s*(${YEAR_PATTERN})?` +\n            `)?` +\n            `(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"янв\", \"фер\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(match.index, match.index + match[0].length);\n        result.start.imply(\"day\", 1);\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n"],"mappings":"AAAA,SAASA,0BAA0B,EAAEC,gBAAgB,QAAQ,iBAAe;AAE5E,SAASC,oBAAoB,QAAQ,+BAA6B;AAClE,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AACvD,SAASC,sCAAsC,QAAQ,6CAA2C;AAElG,MAAMC,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,UAAU,GAAG,CAAC;AAQpB,eAAc,MAAOC,iBAAkB,SAAQH,sCAAsC;EACjFI,kBAAkBA,CAACC,OAAuB;IACtC,OACI,cAAc,GACd,IAAIR,eAAe,CAACF,gBAAgB,CAAC,GAAG,GACxC,MAAM,GACN,KAAK,GACL,aAAaG,YAAY,IAAI,GAC7B,IAAI,GACJ,kCAAkC;EAE1C;EAEAQ,YAAYA,CAACD,OAAuB,EAAEE,KAAuB;IACzD,MAAMC,SAAS,GAAGD,KAAK,CAACN,gBAAgB,CAAC,CAACQ,WAAW,EAAE;IAGvD,IAAIF,KAAK,CAAC,CAAC,CAAC,CAACG,MAAM,IAAI,CAAC,IAAI,CAAChB,0BAA0B,CAACc,SAAS,CAAC,EAAE;MAChE,OAAO,IAAI;;IAGf,MAAMG,MAAM,GAAGN,OAAO,CAACO,mBAAmB,CAACL,KAAK,CAACM,KAAK,EAAEN,KAAK,CAACM,KAAK,GAAGN,KAAK,CAAC,CAAC,CAAC,CAACG,MAAM,CAAC;IACtFC,MAAM,CAACG,KAAK,CAACC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;IAE5B,MAAMC,KAAK,GAAGrB,gBAAgB,CAACa,SAAS,CAAC;IACzCG,MAAM,CAACG,KAAK,CAACG,MAAM,CAAC,OAAO,EAAED,KAAK,CAAC;IAEnC,IAAIT,KAAK,CAACL,UAAU,CAAC,EAAE;MACnB,MAAMgB,IAAI,GAAGnB,SAAS,CAACQ,KAAK,CAACL,UAAU,CAAC,CAAC;MACzCS,MAAM,CAACG,KAAK,CAACG,MAAM,CAAC,MAAM,EAAEC,IAAI,CAAC;KACpC,MAAM;MACH,MAAMA,IAAI,GAAGtB,oBAAoB,CAACS,OAAO,CAACc,OAAO,EAAE,CAAC,EAAEH,KAAK,CAAC;MAC5DL,MAAM,CAACG,KAAK,CAACC,KAAK,CAAC,MAAM,EAAEG,IAAI,CAAC;;IAGpC,OAAOP,MAAM;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}