{"ast":null,"code":"import { AbstractParserWithWordBoundaryChecking } from \"./AbstractParserWithWordBoundary.js\";\nconst PATTERN = new RegExp(\"([0-9]{4})\\\\-([0-9]{1,2})\\\\-([0-9]{1,2})\" + \"(?:T\" + \"([0-9]{1,2}):([0-9]{1,2})\" + \"(?:\" + \":([0-9]{1,2})(?:\\\\.(\\\\d{1,4}))?\" + \")?\" + \"(\" + \"Z|([+-]\\\\d{2}):?(\\\\d{2})?\" + \")?\" + \")?\" + \"(?=\\\\W|$)\", \"i\");\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NUMBER_GROUP = 2;\nconst DATE_NUMBER_GROUP = 3;\nconst HOUR_NUMBER_GROUP = 4;\nconst MINUTE_NUMBER_GROUP = 5;\nconst SECOND_NUMBER_GROUP = 6;\nconst MILLISECOND_NUMBER_GROUP = 7;\nconst TZD_GROUP = 8;\nconst TZD_HOUR_OFFSET_GROUP = 9;\nconst TZD_MINUTE_OFFSET_GROUP = 10;\nexport default class ISOFormatParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const components = context.createParsingComponents({\n      \"year\": parseInt(match[YEAR_NUMBER_GROUP]),\n      \"month\": parseInt(match[MONTH_NUMBER_GROUP]),\n      \"day\": parseInt(match[DATE_NUMBER_GROUP])\n    });\n    if (match[HOUR_NUMBER_GROUP] != null) {\n      components.assign(\"hour\", parseInt(match[HOUR_NUMBER_GROUP]));\n      components.assign(\"minute\", parseInt(match[MINUTE_NUMBER_GROUP]));\n      if (match[SECOND_NUMBER_GROUP] != null) {\n        components.assign(\"second\", parseInt(match[SECOND_NUMBER_GROUP]));\n      }\n      if (match[MILLISECOND_NUMBER_GROUP] != null) {\n        components.assign(\"millisecond\", parseInt(match[MILLISECOND_NUMBER_GROUP]));\n      }\n      if (match[TZD_GROUP] != null) {\n        let offset = 0;\n        if (match[TZD_HOUR_OFFSET_GROUP]) {\n          const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);\n          let minuteOffset = 0;\n          if (match[TZD_MINUTE_OFFSET_GROUP] != null) {\n            minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);\n          }\n          offset = hourOffset * 60;\n          if (offset < 0) {\n            offset -= minuteOffset;\n          } else {\n            offset += minuteOffset;\n          }\n        }\n        components.assign(\"timezoneOffset\", offset);\n      }\n    }\n    return components.addTag(\"parser/ISOFormatParser\");\n  }\n}","map":{"version":3,"names":["AbstractParserWithWordBoundaryChecking","PATTERN","RegExp","YEAR_NUMBER_GROUP","MONTH_NUMBER_GROUP","DATE_NUMBER_GROUP","HOUR_NUMBER_GROUP","MINUTE_NUMBER_GROUP","SECOND_NUMBER_GROUP","MILLISECOND_NUMBER_GROUP","TZD_GROUP","TZD_HOUR_OFFSET_GROUP","TZD_MINUTE_OFFSET_GROUP","ISOFormatParser","innerPattern","innerExtract","context","match","components","createParsingComponents","parseInt","assign","offset","hourOffset","minuteOffset","addTag"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/common/parsers/ISOFormatParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../chrono\";\nimport { Component } from \"../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"./AbstractParserWithWordBoundary\";\n\n// ISO 8601\n// http://www.w3.org/TR/NOTE-datetime\n// - YYYY-MM-DD\n// - YYYY-MM-DDThh:mmTZD\n// - YYYY-MM-DDThh:mm:ssTZD\n// - YYYY-MM-DDThh:mm:ss.sTZD\n// - TZD = (Z or +hh:mm or -hh:mm)\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    \"([0-9]{4})\\\\-([0-9]{1,2})\\\\-([0-9]{1,2})\" +\n    \"(?:T\" + //..\n        \"([0-9]{1,2}):([0-9]{1,2})\" + // hh:mm\n        \"(?:\" +\n            \":([0-9]{1,2})(?:\\\\.(\\\\d{1,4}))?\" +\n        \")?\" + // :ss.s\n        \"(\" +\n            \"Z|([+-]\\\\d{2}):?(\\\\d{2})?\" +\n        \")?\" + // TZD (Z or ±hh:mm or ±hhmm or ±hh)\n    \")?\" +\n    \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NUMBER_GROUP = 2;\nconst DATE_NUMBER_GROUP = 3;\nconst HOUR_NUMBER_GROUP = 4;\nconst MINUTE_NUMBER_GROUP = 5;\nconst SECOND_NUMBER_GROUP = 6;\nconst MILLISECOND_NUMBER_GROUP = 7;\nconst TZD_GROUP = 8;\nconst TZD_HOUR_OFFSET_GROUP = 9;\nconst TZD_MINUTE_OFFSET_GROUP = 10;\n\nexport default class ISOFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const components = context.createParsingComponents({\n            \"year\": parseInt(match[YEAR_NUMBER_GROUP]),\n            \"month\": parseInt(match[MONTH_NUMBER_GROUP]),\n            \"day\": parseInt(match[DATE_NUMBER_GROUP]),\n        });\n        if (match[HOUR_NUMBER_GROUP] != null) {\n            components.assign(\"hour\", parseInt(match[HOUR_NUMBER_GROUP]));\n            components.assign(\"minute\", parseInt(match[MINUTE_NUMBER_GROUP]));\n\n            if (match[SECOND_NUMBER_GROUP] != null) {\n                components.assign(\"second\", parseInt(match[SECOND_NUMBER_GROUP]));\n            }\n\n            if (match[MILLISECOND_NUMBER_GROUP] != null) {\n                components.assign(\"millisecond\", parseInt(match[MILLISECOND_NUMBER_GROUP]));\n            }\n            if (match[TZD_GROUP] != null) {\n                // The Zulu time zone (Z) is equivalent to UTC\n                let offset = 0;\n                if (match[TZD_HOUR_OFFSET_GROUP]) {\n                    const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);\n                    let minuteOffset = 0;\n                    if (match[TZD_MINUTE_OFFSET_GROUP] != null) {\n                        minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);\n                    }\n                    offset = hourOffset * 60;\n                    if (offset < 0) {\n                        offset -= minuteOffset;\n                    } else {\n                        offset += minuteOffset;\n                    }\n                }\n                components.assign(\"timezoneOffset\", offset);\n            }\n        }\n        return components.addTag(\"parser/ISOFormatParser\");\n    }\n}\n"],"mappings":"AAEA,SAASA,sCAAsC,QAAQ,qCAAmC;AAW1F,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,0CAA0C,GAC1C,MAAM,GACF,2BAA2B,GAC3B,KAAK,GACD,iCAAiC,GACrC,IAAI,GACJ,GAAG,GACC,2BAA2B,GAC/B,IAAI,GACR,IAAI,GACJ,WAAW,EACX,GAAG,CACN;AAED,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,mBAAmB,GAAG,CAAC;AAC7B,MAAMC,mBAAmB,GAAG,CAAC;AAC7B,MAAMC,wBAAwB,GAAG,CAAC;AAClC,MAAMC,SAAS,GAAG,CAAC;AACnB,MAAMC,qBAAqB,GAAG,CAAC;AAC/B,MAAMC,uBAAuB,GAAG,EAAE;AAElC,eAAc,MAAOC,eAAgB,SAAQb,sCAAsC;EAC/Ec,YAAYA,CAAA;IACR,OAAOb,OAAO;EAClB;EAEAc,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IACzD,MAAMC,UAAU,GAAGF,OAAO,CAACG,uBAAuB,CAAC;MAC/C,MAAM,EAAEC,QAAQ,CAACH,KAAK,CAACd,iBAAiB,CAAC,CAAC;MAC1C,OAAO,EAAEiB,QAAQ,CAACH,KAAK,CAACb,kBAAkB,CAAC,CAAC;MAC5C,KAAK,EAAEgB,QAAQ,CAACH,KAAK,CAACZ,iBAAiB,CAAC;KAC3C,CAAC;IACF,IAAIY,KAAK,CAACX,iBAAiB,CAAC,IAAI,IAAI,EAAE;MAClCY,UAAU,CAACG,MAAM,CAAC,MAAM,EAAED,QAAQ,CAACH,KAAK,CAACX,iBAAiB,CAAC,CAAC,CAAC;MAC7DY,UAAU,CAACG,MAAM,CAAC,QAAQ,EAAED,QAAQ,CAACH,KAAK,CAACV,mBAAmB,CAAC,CAAC,CAAC;MAEjE,IAAIU,KAAK,CAACT,mBAAmB,CAAC,IAAI,IAAI,EAAE;QACpCU,UAAU,CAACG,MAAM,CAAC,QAAQ,EAAED,QAAQ,CAACH,KAAK,CAACT,mBAAmB,CAAC,CAAC,CAAC;;MAGrE,IAAIS,KAAK,CAACR,wBAAwB,CAAC,IAAI,IAAI,EAAE;QACzCS,UAAU,CAACG,MAAM,CAAC,aAAa,EAAED,QAAQ,CAACH,KAAK,CAACR,wBAAwB,CAAC,CAAC,CAAC;;MAE/E,IAAIQ,KAAK,CAACP,SAAS,CAAC,IAAI,IAAI,EAAE;QAE1B,IAAIY,MAAM,GAAG,CAAC;QACd,IAAIL,KAAK,CAACN,qBAAqB,CAAC,EAAE;UAC9B,MAAMY,UAAU,GAAGH,QAAQ,CAACH,KAAK,CAACN,qBAAqB,CAAC,CAAC;UACzD,IAAIa,YAAY,GAAG,CAAC;UACpB,IAAIP,KAAK,CAACL,uBAAuB,CAAC,IAAI,IAAI,EAAE;YACxCY,YAAY,GAAGJ,QAAQ,CAACH,KAAK,CAACL,uBAAuB,CAAC,CAAC;;UAE3DU,MAAM,GAAGC,UAAU,GAAG,EAAE;UACxB,IAAID,MAAM,GAAG,CAAC,EAAE;YACZA,MAAM,IAAIE,YAAY;WACzB,MAAM;YACHF,MAAM,IAAIE,YAAY;;;QAG9BN,UAAU,CAACG,MAAM,CAAC,gBAAgB,EAAEC,MAAM,CAAC;;;IAGnD,OAAOJ,UAAU,CAACO,MAAM,CAAC,wBAAwB,CAAC;EACtD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}