{"ast":null,"code":"import { GoogleGenerativeAI } from \"@google/generative-ai\";\n\n// Define Interfaces\n\n// ==================================\n// --- PROMPT DEFINITIONS START ---\n// ==================================\n\n// --- Prompt A (Updated detailed prompt) ---\n// Helper to fetch and cache prompts\nconst promptCache = {};\nasync function loadPrompt(promptName) {\n  const filename = promptName === 'A' ? '/prompts/promptA.txt' : '/prompts/promptB.txt';\n  if (promptCache[promptName]) return promptCache[promptName];\n  const response = await fetch(filename);\n  if (!response.ok) throw new Error(`Failed to load prompt ${promptName}`);\n  const text = await response.text();\n  promptCache[promptName] = text;\n  return text;\n}\n\n// Returns the prompt with ${taskTitle} replaced\nasync function getPromptWithTaskTitle(promptName, taskTitle) {\n  const template = await loadPrompt(promptName);\n  return template.replace(/\\$\\{taskTitle\\}/g, taskTitle);\n}\n\n// ==================================\n// --- PROMPT DEFINITIONS END ---\n// ==================================\n\n// --- Service Initialization ---\n\nconst API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\nif (!API_KEY) {\n  console.error(\"CRITICAL ERROR: Missing REACT_APP_GEMINI_API_KEY environment variable.\");\n}\nconst geminiService = API_KEY ? new GoogleGenerativeAI(API_KEY) : null;\n\n// --- API Call Function ---\n\n// Type for selecting prompt\n\n// *** IMPORTANT: Ensure breakDownTask function is updated like this ***\nexport async function breakDownTask(taskTitle, promptVersion) {\n  if (!geminiService) {\n    console.error(\"Gemini service not initialized due to missing API key.\");\n    throw new Error(\"API Key configuration error. Cannot contact AI service.\");\n  }\n  try {\n    const genAI = geminiService;\n    const model = genAI.getGenerativeModel({\n      model: \"gemini-1.5-flash\"\n    });\n\n    // Select the prompt based on the argument\n    // Load the prompt from file and substitute taskTitle\n    const prompt = await getPromptWithTaskTitle(promptVersion, taskTitle);\n    console.log(`Using Prompt ${promptVersion} for task: \"${taskTitle}\"`); // Log which prompt is used\n\n    const result = await model.generateContent(prompt);\n    const response = await result.response;\n    let text = await response.text();\n\n    // Clean the response text\n    text = text.replace(/```json\\n?|```/g, '').trim();\n    console.log(\"Cleaned Gemini Response:\", text);\n\n    // Now expecting pure JSON output from Gemini (Prompt A updated)\n    let parsedSubtasks;\n    // Extract JSON array from the response (find first [ and last ])\n    const jsonStart = text.indexOf('[');\n    const jsonEnd = text.lastIndexOf(']');\n    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {\n      const jsonStr = text.substring(jsonStart, jsonEnd + 1);\n      try {\n        parsedSubtasks = JSON.parse(jsonStr);\n        // Add unique IDs and ensure completed status is false\n        parsedSubtasks = parsedSubtasks.map(subtask => ({\n          ...subtask,\n          dependsOn: Array.isArray(subtask.dependsOn) ? subtask.dependsOn : [],\n          completed: false,\n          uuid: Date.now().toString() + Math.random().toString(36).substring(2, 9) // for React key if needed\n        }));\n      } catch (parseError) {\n        console.error(\"Failed to parse Gemini JSON substring:\", parseError, \"Raw JSON:\", jsonStr);\n        // Handle the \"no breakdown needed\" case from Prompt B gracefully\n        if (text.includes(\"No breakdown needed\") || text.includes(\"task seems straightforward\")) {\n          console.log(\"Detected 'no breakdown needed' response type.\");\n          return [{\n            id: Date.now().toString() + Math.random().toString(36).substring(2, 9),\n            title: \"No breakdown needed / Simple task\",\n            completed: false,\n            dependsOn: [],\n            estimatedTime: \"\"\n          }];\n        }\n        throw new Error('Failed to parse task breakdown response');\n      }\n    } else {\n      // If no JSON found, handle as before\n      console.error(\"No JSON array found in Gemini response.\");\n      if (text.includes(\"No breakdown needed\") || text.includes(\"task seems straightforward\")) {\n        return [{\n          id: Date.now().toString() + Math.random().toString(36).substring(2, 9),\n          title: \"No breakdown needed / Simple task\",\n          completed: false,\n          dependsOn: [],\n          estimatedTime: \"\"\n        }];\n      }\n      throw new Error('Failed to parse task breakdown response');\n    }\n    console.log(\"Parsed Subtasks:\", parsedSubtasks);\n    return parsedSubtasks;\n  } catch (error) {\n    console.error(\"Error breaking down task:\", error);\n    if (error instanceof Error && error.message.includes(\"API key not valid\")) {\n      throw new Error('Invalid API Key. Please check your .env file and Google AI Studio settings.');\n    }\n    if (error instanceof Error && error.message.includes(\"400\")) {\n      console.error(\"Potential issue with prompt or model request.\");\n      throw new Error('Error processing task breakdown with AI. Check console for details.');\n    }\n    throw new Error('Failed to break down task');\n  }\n}","map":{"version":3,"names":["GoogleGenerativeAI","promptCache","loadPrompt","promptName","filename","response","fetch","ok","Error","text","getPromptWithTaskTitle","taskTitle","template","replace","API_KEY","process","env","REACT_APP_GEMINI_API_KEY","console","error","geminiService","breakDownTask","promptVersion","genAI","model","getGenerativeModel","prompt","log","result","generateContent","trim","parsedSubtasks","jsonStart","indexOf","jsonEnd","lastIndexOf","jsonStr","substring","JSON","parse","map","subtask","dependsOn","Array","isArray","completed","uuid","Date","now","toString","Math","random","parseError","includes","id","title","estimatedTime","message"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/src/services/geminiService.ts"],"sourcesContent":["import { GoogleGenerativeAI } from \"@google/generative-ai\";\n\n// Define Interfaces\nexport interface Task {\n  id: string;\n  title: string;\n  completed: boolean;\n}\n\nexport interface SubTask {\n  id: string; // Added unique ID\n  title: string;\n  completed: boolean;\n  dependsOn: (string | number)[]; // Added dependency array\n  estimatedTime?: string; // Optional estimated time\n}\n\nexport interface TaskWithSubTasks extends Task {\n  subTasks: SubTask[];\n  totalEstimatedTime?: string; // Added total estimated time for the main task\n  dueDate?: Date | null;         // Added due date\n}\n\n// ==================================\n// --- PROMPT DEFINITIONS START ---\n// ==================================\n\n// --- Prompt A (Updated detailed prompt) ---\n// Helper to fetch and cache prompts\nconst promptCache: Record<string, string> = {};\nasync function loadPrompt(promptName: 'A' | 'B'): Promise<string> {\n  const filename = promptName === 'A' ? '/prompts/promptA.txt' : '/prompts/promptB.txt';\n  if (promptCache[promptName]) return promptCache[promptName];\n  const response = await fetch(filename);\n  if (!response.ok) throw new Error(`Failed to load prompt ${promptName}`);\n  const text = await response.text();\n  promptCache[promptName] = text;\n  return text;\n}\n\n// Returns the prompt with ${taskTitle} replaced\nasync function getPromptWithTaskTitle(promptName: 'A' | 'B', taskTitle: string): Promise<string> {\n  const template = await loadPrompt(promptName);\n  return template.replace(/\\$\\{taskTitle\\}/g, taskTitle);\n}\n\n\n// ==================================\n// --- PROMPT DEFINITIONS END ---\n// ==================================\n\n// --- Service Initialization ---\n\nconst API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\n\nif (!API_KEY) {\n  console.error(\"CRITICAL ERROR: Missing REACT_APP_GEMINI_API_KEY environment variable.\");\n}\n\nconst geminiService = API_KEY ? new GoogleGenerativeAI(API_KEY) : null;\n\n// --- API Call Function ---\n\nexport type PromptSelection = 'A' | 'B'; // Type for selecting prompt\n\n// *** IMPORTANT: Ensure breakDownTask function is updated like this ***\nexport async function breakDownTask(\n  taskTitle: string,\n  promptVersion: PromptSelection // Added parameter to select prompt\n): Promise<SubTask[]> {\n  if (!geminiService) {\n    console.error(\"Gemini service not initialized due to missing API key.\");\n    throw new Error(\"API Key configuration error. Cannot contact AI service.\");\n  }\n\n  try {\n    const genAI = geminiService;\n    const model = genAI.getGenerativeModel({\n      model: \"gemini-1.5-flash\",\n    });\n\n    // Select the prompt based on the argument\n    // Load the prompt from file and substitute taskTitle\n    const prompt = await getPromptWithTaskTitle(promptVersion, taskTitle);\n\n    console.log(`Using Prompt ${promptVersion} for task: \"${taskTitle}\"`); // Log which prompt is used\n\n    const result = await model.generateContent(prompt);\n    const response = await result.response;\n    let text = await response.text();\n\n    // Clean the response text\n    text = text.replace(/```json\\n?|```/g, '').trim();\n    console.log(\"Cleaned Gemini Response:\", text);\n\n    // Now expecting pure JSON output from Gemini (Prompt A updated)\n    let parsedSubtasks: SubTask[];\n    // Extract JSON array from the response (find first [ and last ])\n    const jsonStart = text.indexOf('[');\n    const jsonEnd = text.lastIndexOf(']');\n    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {\n      const jsonStr = text.substring(jsonStart, jsonEnd + 1);\n      try {\n        parsedSubtasks = JSON.parse(jsonStr);\n        // Add unique IDs and ensure completed status is false\n        parsedSubtasks = parsedSubtasks.map(subtask => ({\n          ...subtask,\n          dependsOn: Array.isArray(subtask.dependsOn) ? subtask.dependsOn : [],\n          completed: false,\n          uuid: Date.now().toString() + Math.random().toString(36).substring(2, 9) // for React key if needed\n        }));\n      } catch (parseError) {\n        console.error(\"Failed to parse Gemini JSON substring:\", parseError, \"Raw JSON:\", jsonStr);\n        // Handle the \"no breakdown needed\" case from Prompt B gracefully\n        if (text.includes(\"No breakdown needed\") || text.includes(\"task seems straightforward\")) {\n          console.log(\"Detected 'no breakdown needed' response type.\");\n          return [{\n            id: Date.now().toString() + Math.random().toString(36).substring(2, 9),\n            title: \"No breakdown needed / Simple task\",\n            completed: false,\n            dependsOn: [],\n            estimatedTime: \"\"\n          }];\n        }\n        throw new Error('Failed to parse task breakdown response');\n      }\n    } else {\n      // If no JSON found, handle as before\n      console.error(\"No JSON array found in Gemini response.\");\n      if (text.includes(\"No breakdown needed\") || text.includes(\"task seems straightforward\")) {\n        return [{\n          id: Date.now().toString() + Math.random().toString(36).substring(2, 9),\n          title: \"No breakdown needed / Simple task\",\n          completed: false,\n          dependsOn: [],\n          estimatedTime: \"\"\n        }];\n      }\n      throw new Error('Failed to parse task breakdown response');\n    }\n\n    console.log(\"Parsed Subtasks:\", parsedSubtasks);\n    return parsedSubtasks;\n  } catch (error) {\n    console.error(\"Error breaking down task:\", error);\n    if (error instanceof Error && error.message.includes(\"API key not valid\")) {\n      throw new Error('Invalid API Key. Please check your .env file and Google AI Studio settings.');\n    }\n    if (error instanceof Error && error.message.includes(\"400\")) {\n      console.error(\"Potential issue with prompt or model request.\");\n      throw new Error('Error processing task breakdown with AI. Check console for details.');\n    }\n    throw new Error('Failed to break down task');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}