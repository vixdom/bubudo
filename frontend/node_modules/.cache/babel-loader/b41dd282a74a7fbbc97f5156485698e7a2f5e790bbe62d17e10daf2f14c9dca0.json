{"ast":null,"code":"export class Filter {\n  refine(context, results) {\n    return results.filter(r => this.isValid(context, r));\n  }\n}\nexport class MergingRefiner {\n  refine(context, results) {\n    if (results.length < 2) {\n      return results;\n    }\n    const mergedResults = [];\n    let curResult = results[0];\n    let nextResult = null;\n    for (let i = 1; i < results.length; i++) {\n      nextResult = results[i];\n      const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);\n      if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {\n        mergedResults.push(curResult);\n        curResult = nextResult;\n      } else {\n        const left = curResult;\n        const right = nextResult;\n        const mergedResult = this.mergeResults(textBetween, left, right, context);\n        context.debug(() => {\n          console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);\n        });\n        curResult = mergedResult;\n      }\n    }\n    if (curResult != null) {\n      mergedResults.push(curResult);\n    }\n    return mergedResults;\n  }\n}","map":{"version":3,"names":["Filter","refine","context","results","filter","r","isValid","MergingRefiner","length","mergedResults","curResult","nextResult","i","textBetween","text","substring","index","shouldMergeResults","push","left","right","mergedResult","mergeResults","debug","console","log","constructor","name"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/common/abstractRefiners.ts"],"sourcesContent":["import { ParsingContext, Refiner } from \"../chrono\";\nimport { ParsingResult } from \"../results\";\n\n/**\n * A special type of {@link Refiner} to filter the results\n */\nexport abstract class Filter implements Refiner {\n    abstract isValid(context: ParsingContext, result: ParsingResult): boolean;\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        return results.filter((r) => this.isValid(context, r));\n    }\n}\n\n/**\n * A special type of {@link Refiner} to merge consecutive results\n */\nexport abstract class MergingRefiner implements Refiner {\n    abstract shouldMergeResults(\n        textBetween: string,\n        currentResult: ParsingResult,\n        nextResult: ParsingResult,\n        context: ParsingContext\n    ): boolean;\n\n    abstract mergeResults(\n        textBetween: string,\n        currentResult: ParsingResult,\n        nextResult: ParsingResult,\n        context: ParsingContext\n    ): ParsingResult;\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (results.length < 2) {\n            return results;\n        }\n\n        const mergedResults: ParsingResult[] = [];\n        let curResult = results[0];\n        let nextResult = null;\n\n        for (let i = 1; i < results.length; i++) {\n            nextResult = results[i];\n\n            const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);\n            if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {\n                mergedResults.push(curResult);\n                curResult = nextResult;\n            } else {\n                const left = curResult;\n                const right = nextResult;\n                const mergedResult = this.mergeResults(textBetween, left, right, context);\n                context.debug(() => {\n                    console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);\n                });\n\n                curResult = mergedResult;\n            }\n        }\n\n        if (curResult != null) {\n            mergedResults.push(curResult);\n        }\n\n        return mergedResults;\n    }\n}\n"],"mappings":"AAMA,OAAM,MAAgBA,MAAM;EAGxBC,MAAMA,CAACC,OAAuB,EAAEC,OAAwB;IACpD,OAAOA,OAAO,CAACC,MAAM,CAAEC,CAAC,IAAK,IAAI,CAACC,OAAO,CAACJ,OAAO,EAAEG,CAAC,CAAC,CAAC;EAC1D;;AAMJ,OAAM,MAAgBE,cAAc;EAehCN,MAAMA,CAACC,OAAuB,EAAEC,OAAwB;IACpD,IAAIA,OAAO,CAACK,MAAM,GAAG,CAAC,EAAE;MACpB,OAAOL,OAAO;;IAGlB,MAAMM,aAAa,GAAoB,EAAE;IACzC,IAAIC,SAAS,GAAGP,OAAO,CAAC,CAAC,CAAC;IAC1B,IAAIQ,UAAU,GAAG,IAAI;IAErB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,OAAO,CAACK,MAAM,EAAEI,CAAC,EAAE,EAAE;MACrCD,UAAU,GAAGR,OAAO,CAACS,CAAC,CAAC;MAEvB,MAAMC,WAAW,GAAGX,OAAO,CAACY,IAAI,CAACC,SAAS,CAACL,SAAS,CAACM,KAAK,GAAGN,SAAS,CAACI,IAAI,CAACN,MAAM,EAAEG,UAAU,CAACK,KAAK,CAAC;MACrG,IAAI,CAAC,IAAI,CAACC,kBAAkB,CAACJ,WAAW,EAAEH,SAAS,EAAEC,UAAU,EAAET,OAAO,CAAC,EAAE;QACvEO,aAAa,CAACS,IAAI,CAACR,SAAS,CAAC;QAC7BA,SAAS,GAAGC,UAAU;OACzB,MAAM;QACH,MAAMQ,IAAI,GAAGT,SAAS;QACtB,MAAMU,KAAK,GAAGT,UAAU;QACxB,MAAMU,YAAY,GAAG,IAAI,CAACC,YAAY,CAACT,WAAW,EAAEM,IAAI,EAAEC,KAAK,EAAElB,OAAO,CAAC;QACzEA,OAAO,CAACqB,KAAK,CAAC,MAAK;UACfC,OAAO,CAACC,GAAG,CAAC,GAAG,IAAI,CAACC,WAAW,CAACC,IAAI,WAAWR,IAAI,QAAQC,KAAK,SAASC,YAAY,EAAE,CAAC;QAC5F,CAAC,CAAC;QAEFX,SAAS,GAAGW,YAAY;;;IAIhC,IAAIX,SAAS,IAAI,IAAI,EAAE;MACnBD,aAAa,CAACS,IAAI,CAACR,SAAS,CAAC;;IAGjC,OAAOD,aAAa;EACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}