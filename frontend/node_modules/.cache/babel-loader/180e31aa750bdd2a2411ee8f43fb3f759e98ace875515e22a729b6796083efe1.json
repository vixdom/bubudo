{"ast":null,"code":"export function repeatedTimeunitPattern(prefix, singleTimeunitPattern, connectorPattern = \"\\\\s{0,5},?\\\\s{0,5}\") {\n  const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\\((?!\\?)/g, \"(?:\");\n  return `${prefix}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;\n}\nexport function extractTerms(dictionary) {\n  let keys;\n  if (dictionary instanceof Array) {\n    keys = [...dictionary];\n  } else if (dictionary instanceof Map) {\n    keys = Array.from(dictionary.keys());\n  } else {\n    keys = Object.keys(dictionary);\n  }\n  return keys;\n}\nexport function matchAnyPattern(dictionary) {\n  const joinedTerms = extractTerms(dictionary).sort((a, b) => b.length - a.length).join(\"|\").replace(/\\./g, \"\\\\.\");\n  return `(?:${joinedTerms})`;\n}","map":{"version":3,"names":["repeatedTimeunitPattern","prefix","singleTimeunitPattern","connectorPattern","singleTimeunitPatternNoCapture","replace","extractTerms","dictionary","keys","Array","Map","from","Object","matchAnyPattern","joinedTerms","sort","a","b","length","join"],"sources":["/Users/mvikr/Projects/TaskApp/frontend/node_modules/chrono-node/src/utils/pattern.ts"],"sourcesContent":["type DictionaryLike = string[] | { [word: string]: unknown } | Map<string, unknown>;\n\nexport function repeatedTimeunitPattern(\n    prefix: string,\n    singleTimeunitPattern: string,\n    connectorPattern = \"\\\\s{0,5},?\\\\s{0,5}\"\n): string {\n    const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\\((?!\\?)/g, \"(?:\");\n    return `${prefix}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;\n}\n\nexport function extractTerms(dictionary: DictionaryLike): string[] {\n    let keys: string[];\n    if (dictionary instanceof Array) {\n        keys = [...dictionary];\n    } else if (dictionary instanceof Map) {\n        keys = Array.from((dictionary as Map<string, unknown>).keys());\n    } else {\n        keys = Object.keys(dictionary);\n    }\n\n    return keys;\n}\n\nexport function matchAnyPattern(dictionary: DictionaryLike): string {\n    // TODO: More efficient regex pattern by considering duplicated prefix\n\n    const joinedTerms = extractTerms(dictionary)\n        .sort((a, b) => b.length - a.length)\n        .join(\"|\")\n        .replace(/\\./g, \"\\\\.\");\n\n    return `(?:${joinedTerms})`;\n}\n"],"mappings":"AAEA,OAAM,SAAUA,uBAAuBA,CACnCC,MAAc,EACdC,qBAA6B,EAC7BC,gBAAgB,GAAG,oBAAoB;EAEvC,MAAMC,8BAA8B,GAAGF,qBAAqB,CAACG,OAAO,CAAC,WAAW,EAAE,KAAK,CAAC;EACxF,OAAO,GAAGJ,MAAM,GAAGG,8BAA8B,MAAMD,gBAAgB,GAAGC,8BAA8B,SAAS;AACrH;AAEA,OAAM,SAAUE,YAAYA,CAACC,UAA0B;EACnD,IAAIC,IAAc;EAClB,IAAID,UAAU,YAAYE,KAAK,EAAE;IAC7BD,IAAI,GAAG,CAAC,GAAGD,UAAU,CAAC;GACzB,MAAM,IAAIA,UAAU,YAAYG,GAAG,EAAE;IAClCF,IAAI,GAAGC,KAAK,CAACE,IAAI,CAAEJ,UAAmC,CAACC,IAAI,EAAE,CAAC;GACjE,MAAM;IACHA,IAAI,GAAGI,MAAM,CAACJ,IAAI,CAACD,UAAU,CAAC;;EAGlC,OAAOC,IAAI;AACf;AAEA,OAAM,SAAUK,eAAeA,CAACN,UAA0B;EAGtD,MAAMO,WAAW,GAAGR,YAAY,CAACC,UAAU,CAAC,CACvCQ,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACC,MAAM,GAAGF,CAAC,CAACE,MAAM,CAAC,CACnCC,IAAI,CAAC,GAAG,CAAC,CACTd,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;EAE1B,OAAO,MAAMS,WAAW,GAAG;AAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}